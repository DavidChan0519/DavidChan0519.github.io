<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用clion编译c++程序报错]]></title>
    <url>%2F2019%2F04%2F02%2Fclion-compile-err%2F</url>
    <content type="text"><![CDATA[问题描述：Clion编译c++程序，报错 “wchar.h not found” 12345678/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h:119:15:** **fatal error:** 'wchar.h' file not found**\#include_next &lt;wchar.h&gt;^~~~~~~~~1 error generated.make[2]: *** [CMakeFiles/test_virtual.bin.dir/test_virtual.cpp.o] Error 1make[1]: *** [CMakeFiles/test_virtual.bin.dir/all] Error 2make: *** [all] Error 2 解决办法：click “Tools -&gt; CMake -&gt; ResetCache and Reload Project” 重新编译即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Dockerfile中使用COPY指令]]></title>
    <url>%2F2019%2F04%2F02%2Fdockerfile-copy%2F</url>
    <content type="text"><![CDATA[COPY指令:1COPY &lt;src&gt; &lt;dest&gt; 我们在使用dockerfile构建docker镜像时，通常会用到COPY指令。COPY指令用于将系统本地的文件拷贝至docker镜像中。但是其中有一个地方需要特别注意：即build上下文. 在使用 docker build 命令通过 Dockerfile 创建镜像时，会产生一个 build 上下文(context)。所谓的 build 上下文就是 docker build 命令的 PATH 或 URL 指定的路径中的文件的集合。在镜像 build 过程中可以引用上下文中的任何文件，比如我们要介绍的 COPY 命令，就可以引用上下文中的文件。 默认情况下 docker build -t custom . 命令中的 . 表示build上下文为当前目录。 当然我们可以指定一个目录作为上下文，比如： 1$docker build -t custom /home/linaro 注意事项：在使用COPY指令时，本地的源文件要位于build上下文中。 如果build上下文是当前目录，则源文件要位于dockerfile所在的当前目录。 例如： 12WORKDIR /workCOPY snmp . snmp目录要位于dockerfile所在的目录中 否则build过程中会报错：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git for Gerrit 客户端配置指导]]></title>
    <url>%2F2019%2F04%2F02%2Fgit-and-gerrit-guide%2F</url>
    <content type="text"><![CDATA[Install and config Gitinstall git1$sudo apt-get install git config git1$git config --global user.name "Your Name" 1$git config --global user.email "your.email@gmail.com" Note：”Your Name” must be same with your domain name, for example wei.cheng Check config information1$git config --list Generate and upload ssh keyOn Linux 1$ssh-keygen -t rsa -C "your.email@gmail.com" Don’t use any passphrase 1$vim ~/.ssh/config 123456----------------------------------------------------------------Host * KexAlgorithms +diffie-hellman-group1-sha1---------------------------------------------------------------- 1$cat ~/.ssh/id_rsa.pub Copy the whole file into clipboardOpen gerrit website , On website, goto “Settings -&gt; SSH Public Keys”, paste the key, press “Add” Clone projects12345678910111213141516$git clone &lt;ssh://your.name@gerrit.ai.bmfusion.net:29418/xxx.git&gt;$git submodule init$git submodule update --rebase --remote$git fetch origin$git rebase origin/master#Do merge if needed, after solving conflict, run$git rebase --continue#Amend the previous change if needed$git commit --amend#Push$git push origin HEAD:refs/for/master]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV源码编译安装]]></title>
    <url>%2F2019%2F04%2F02%2Fopencv-src-compile%2F</url>
    <content type="text"><![CDATA[从官网下载最新版4.0.1源码，解压缩，并按以下步骤执行： 进入源码目录1$cd opencv-4.0.1 创建编译目录build，使用cmake进行源码外编译 如果系统没有安装cmake工具，请先安装cmake 1$mkdir build 进入编译目录1$cd build 配置 指定编译后lib文件和头文件的安装路径为/usr/local，默认生成pkgconfig文件，编译python接口 1$cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_GENERATE_PKGCONFIG=ON -D BUILD_opencv_python2=ON ../ 编译1$make -j4 安装1$sudo make install 注：如果cmake配置增加 -D BUILD_opencv_world=ON 选项编译，会将所有动态库融合为一个动态库opencv_world.so 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go编程语法注意事项]]></title>
    <url>%2F2019%2F04%2F01%2Fgo-syntax%2F</url>
    <content type="text"><![CDATA[看完《Go语言实战》和《Go核心编程》这两本教程，自己总结了一些使用Go编程的要领和注意事项 使用 := 赋值操作符，这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明； 全局变量允许声明但不使用，但是局部变量声明后不使用，则编译会报错； 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，但是两个变量的类型必须相同； Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑； 字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组； 获取字符串中某个字节的地址的行为是非法的，例如： 12str := "hello world"&amp;str[i] switch语句case中不需要break来结束; 未初始化的map的值是nil。map默认是无序的,既不是按照key的顺序排列，也不是按照value排序的; 无论是结构体还是结构体指针类型，都使用点号来获取结构体字段（不同于C/C++，指针使用-&gt;来获取成员变量）; 如果File是一个结构体类型，那么表达式 12new(File)&amp;File&#123; &#125; 是等价的 在一个结构体中,对于每一种数据类型只能有一个匿名字段; 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法，比较类似于面向对象里面的继承; 空接口： type Any interface{ }，不实现任何方法，所以任何类型都实现了空接口. 可以给一个空接口类型的变量赋任何类型的值， 每个空接口类型变量占用2个字节：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针,空接口类似于C语言的*void指针； 复制数据切片至空接口切片必须逐一赋值，因为内存布局不一样； 结构struct中只有被导出字段（首字母大写）才是可设置的； 实际上，反射是通过检查一个接口的值，变量首先被转换成空接口； 类型可以通过内嵌多个接口来提供像多重继承一样的特性； 函数重载通过空接口实现； 封装：1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见；2）可导出的：通过标识符首字母大写，对象对所在包以外也可见； 继承： 用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现； 多态： 用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现； 字节切片初始化方式： 1）圆括号会进行类型转换；2）花括号则直接赋值； 当调用panic时，所有的defer语句都会保证执行，并把控制权交还给panic的函数调用者； panic会导致栈被展开直到defer修饰的recover()被调用或者程序中止，recover只能在defer修饰的函数； 执行go test用于测试单个文件时，一定要后跟被测试的源代码文件，如果原文件有其他的引用，有需要一并跟上，否则会提示引用找不到的错误； 协程工作在相同的地址空间，所以共享内存的方式一定是同步的；协程是轻量的，比线程更轻; 经验法则，对于n个核心的情况设置GOMAXPROCS 为n-1以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1+GOMAXPROCS &gt; 1； 如果在某一时间只有一个协程在执行，不要设置GOMAXPROCS！ GOMAXPROCS等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行； 协程会随着程序的结束而自动消亡； 协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序； 通道只能传输一种类型的数据, 所有的类型都可以用于通道，空接口interface{}也可以。甚至可以（有时非常有用）创建通道的通道； 一个无缓冲通道只能包含1个元素, 带缓冲的通道包含多个元素； 关闭通道： 只有发送者才需要关闭通道，接收者不需要关闭通道； 所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名； import导入包时，如果包名前有下划线_，表示初始化该包，但是不是用包里的变量； 程序中每个代码文件里的 init 函数都会在 main 函数执行前调用； 包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其其包中的代码直接访问； 包名应该使用全小写命名 如果使用 … 替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度； 如果在[ ]运算符里指定了一个值，那么创建的就是数组而不是切片。只有为空的时候，才会创建切片； nil切片不同于空切片, 成员指针变量的值不一样，前者值为nil，后者值为0； 切片赋值，共享底层数组； 如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改； 在函数间传递切片，就是要在函数间以值的方式传递切片，这里值传递是指的拷贝地址，实际的切片元素值是不用拷贝的； 在64位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节； 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组，值传递； 用type声明的新类型与原类型是两个完全不同的类型，不能互相赋值； go语言里面有两种类型的接受者（1-值接收者；2-指针接收者） 两种类型的方法，可以彼此互相调用; 值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法(方法对值的修改会影响实际值)。 在实际编写代码时，还要看值类型，是否方便复制（如果值中包含未公开类型，则不能复制） 接口： 用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现； 123type Maker interface &#123; Make()&#125; 当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见 带缓冲的通道，当主动close通道后，goroutine依然可以从通道接收数据，但是不能再往通道发送数据了 iota的使用，默认为0，逐步递增； 字符串类型在 go里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节 在定义常量组时，如果不提供初始值，则表示将使用上一行的表达式； 123456789const ( Sunday = 0 Monday Tuesday Wednesday Thursday Friday Saturday) Sunday为0，其他常量均为0 可以通过将非可变参数置于可变参数前面的方式来混合使用它们，注意：非可变参数只能放在可变参数前面； 使用os.Exit(0)函数退出程序，之前声明的defer函数不会执行； go语言有指针，但是没有指针运算，不能对指针进行偏移； 初始化顺序： 全局变量 -&gt; init() -&gt; main()； package 基本的管理单元：同一个package下面，可以有非常多的不同文件，只要每个文件的头部 都有 如 “package xxx” 的相同name, 表示这些文件属于同一个包； import导入包滥用时，可能会存在循环依赖的问题，需要主动避免； 空切片和nil切片是两个完全不同的概念；nil切片：只声明，不做初始化空切片：声明后初始化为空]]></content>
  </entry>
  <entry>
    <title><![CDATA[上传Docker镜像到私有镜像仓储]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-priv-repo-setup%2F</url>
    <content type="text"><![CDATA[出于信息安全，版本控制等因素考虑，自己搭建docker镜像仓储（搭建教程本文不介绍），可以方便有效的管理大量本地的docker镜像。本文主要介绍如何上传本地的docker镜像到自己搭建的私有镜像仓储 配置本地docker在 /etc/docker/daemon.json（如果没有该文件，则可创建一个） 填入如下字段: 12345&#123; "insecure-registries":[ "10.30.37.149:6000" ]&#125; 10.30.37.149为自己搭建的docker镜像仓储服务器IP，6000为服务器开放的端口 然后执行以下命令重新启动docker 1$sudo systemctl reload docker 如果不做以上配置，push镜像的时候会报以下错误：http: server gave HTTP response to HTTPS client 给需要上传的镜像打tag1$sudo docker tag 3dbe0975429e 10.30.37.149:6000 /bm1682_debian:1.1.1 3dbe0975429e 为本地需要上传的镜像的IMAGE ID， tag格式：私有镜像仓储服务器IP:端口/镜像名称:版本号 上传镜像到私有仓储1$sudo docker push 10.30.37.149:6000/bm1682_debian:1.1.1 下载私有仓储的镜像到本地1sudo docker pull 10.30.37.149:6000/bm1682_debian:1.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 容器端口映射方法]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-port-expose%2F</url>
    <content type="text"><![CDATA[docker容器在启动的时候，如果不指定端口映射参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 现在有如下两种方式导出端口： 启动容器的时候通过-P，-p或者–expose参数动态指定： 端口映射支持的格式 ip : host port : container port #指定宿主机ip、指定宿主机port、指定容器 ip :: container port #指定ip、指定容器port host port : container port #指定宿主机port、指定容器port 1$docker run -P -it ubuntu /bin/bash 以上指令会将容器暴露的所有端口，都随机映射到宿主机上(不推荐) 1$docker run -P 80 -it ubuntu /bin/bash 以上指令会将容器的80端口随机映射到宿主机的一个端口上 1$docker run -p 8000:80 -it ubuntu /bin/bash 以上指令会将容器的80端口映射到宿主机的8000端口上 1$docker run -P 192.168.0.100::80 -it ubuntu /bin/bash 以上指令会将容器的IP 192.168.0.100和80端口，映射到宿主机的8000端口 1docker run -p 1000-2000:1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，映射到宿主机端口1000-2000 1$docker run --expose=1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，随机映射到宿主机端口上 在Dockerfile里面通过EXPOSE指令静态配置：EXPOSE指令只是指定暴露容器内部端口，映射规则还需要在运行容器时通过-P参数指定 1234567891011# GET_IMAGEFROM centos# MAINTAINER_INFOMAINTAINER hongxue hongxue@showjoy.comRUN yum -y install vim# PORTEXPOSE 8080EXPOSE 22 上述Dockerfile暴露了容器内的8080和22两个端口给宿主机。 运行容器时，通过增加-P参数，Docker会自动为用户创建端口映射规则，并且帮助避免端口映射的冲突，这两个端口会被随机映射到宿主机上的两个端口上， 1$docker run -d -it -P --name container_name image_name EXPOSE指令也支持指定端口范围 1EXPOSE 7000-8000 查看指定容器端口映射配置:示例： 12$docker port container_ID ``#容器ID80/tcp -&gt; 0.0.0.0:800]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP企业节点动态库编辑]]></title>
    <url>%2F2019%2F03%2F29%2Fenterprise-priv%2F</url>
    <content type="text"><![CDATA[查阅net-snmp的相关资料，目前Net-SNMP有多种使用方式。本文只介绍snmpd + 企业私有节点动态库的方式。目前这种方式也在多数企业中得到广泛使用。使用这种方式的优点：不用修改net-snmp源码；第一次交叉编译net-snmp生成snmpd后，后面新增feature，修复bug等不需要重新编译net-snmp源码，仅仅维护企业节点动态库就可以了。 企业节点动态库初始化函数在使用mib2c工具自动生成相应代码后，还需要在代码中添加一个启动函数，该启动函数是snmpd守护进程调用企业节点动态库的入口： 123void init_bmserv(void)｛ ...｝ 该函数bmserv的命名应同生成的动态库名称libbmserv.so要保持一致 Makefile交叉编译动态库，模版makefile如下(根据实际环境进行修改适配)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#************************************************************# 通用Makefile#************************************************************CC = aarch64-linux-gnu-gcc#************************************************************# 编译选项#************************************************************# 宏定义选项MACRO_FLAGS := # 使用到的库，只要写lib后的名称，不用加.so或.aLIB_FLAGS := curl crypto cjson# 编译.c到.o文件的选项CC_FLAGS := -Wall -fPIC# 连接.o文件用到的选项LINK_FLAGS := -Wall -fPIC -lpthread -shared#************************************************************# 源代码目录#************************************************************ROOT := $(shell pwd)SRCDIRS := $(ROOT)# ************************************************************# 头文件目录# ************************************************************INCLUDE_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/include/#************************************************************# 动态库、静态库目录#************************************************************LIB_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/openssl/lib/arm64/#************************************************************# 最终生成的程序名称#************************************************************TARGET := libbmserv.so#************************************************************# 被编译的.c文件#************************************************************SRC_C := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))#************************************************************# 所有的.o文件#************************************************************OBJ_C := $(notdir $(patsubst %.c, %.o, $(SRC_C)))#************************************************************# 编译规则#************************************************************.PHONY: all cmd_init cmd_last cleanall:cmd_init $(TARGET) cmd_last# 编译前命令cmd_init: @echo "SRC DIR:" $(SRCDIRS) @echo cmd_init# 编译后命令cmd_last: @echo cmd_lastVPATH = $(SRCDIRS)$(TARGET):$(OBJ_C) $(CC) $(LINK_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) $(LIB_DIRS:%=-L%) -o $@ $^ $(LIB_FLAGS:%=-l%) $(OBJ_C):%.o:%.c $(CC) $(CC_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) -c -o $@ $&lt;clean: rm -f *.o rm -f $(TARGET) 编译 1$make 即可在当前目录下生成企业私有节点动态库libbmserv.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP ARM部署]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp-deployment%2F</url>
    <content type="text"><![CDATA[交叉编译 net-snmp交叉编译，生成snmpd 交叉编译企业私有节点动态库 libbmserv.so 简单版配置文件snmpd.conf1234567891011121314151617181920212223242526272829############################################################################ snmpd.conf###########################################################################dlmod bmserv /usr/lib/libbmserv.so#v1/v2crocommunity rrrrrrwcommunity wwww#v1 traptrapsink 10.30.33.2 rrrrr#v2c traptrap2sink 10.30.33.2 rrrrr#v2c informinformsink 10.30.33.2 rrrrr#v3engineIDType 3rouser rouser privcreateUser rouser MD5 11111111 DES 22222222rwuser rwuser privcreateUser rwuser MD5 33333333 DES 44444444# v3 traptrapsess -v 3 -u rouser -a MD5 -A 11111111 -x DES -X 22222222 -l priv 192.168.1.111 engineType. 1|2|3 : SNMP v3的安全配置，engine id的产生依赖于此选项自动生成； 配置了该选项，就不需要在trapsess选项中通过-e参数来手动指定engine id，否则就需要. specifies that the engineID should be built from the IPv4 address (1), IPv6 address (2) or MAC address (3). Note that changing the IP address (or switching the network interface card) may cause problems. ARM部署将snmpd，libbmserv.so，snmpd.conf及相关的net-snmp库文件打包，然后放到arm开发环境。 snmpd一般放在/bin目录下，snmpd.conf一般放在/etc/snmp/config目录下(没有的话，可自己建立相应的目录) libbmserv.so及net-snmp的动态库文件都可以放在/usr/local/lib下，私有mib文件及公共mib文件都放在/usr/share/mibs下，通过MIBS环境变量指定路径 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/Bitmain.mib 手动启动1$snmpd -f -c /etc/snmp/config/snmpd.conf 全部可选参数如下： OPTIONS -a Log the source addresses of incoming requests. -A Append to the log file rather than truncating it. 默认每次重新启动snmpd，snmpd.log会被清理掉以便重新记录日志，之前旧的日志会被丢弃; 添加-A选项后，旧日志被保留，新的日志追加在旧的日志尾部 -c FILE Read FILE as a configuration file (or a comma-separated list of configuration files). Note that the loaded file will only understand snmpd.conf tokens, unless the configuration type is specified in the file as described in the snmp_config man page under SWITCHING CONFIGURATION TYPES IN MID-FILE. -C Do not read any configuration files except the ones optionally specified by the -c option. Note that this behaviour also covers the persistent configuration files. This may result in dynamically-assigned values being reset following an agent restart, unless the relevant persistent config files are explicitly loaded using the -c option. -d Dump (in hexadecimal) the sent and received SNMP packets. -D[TOKEN[,…]] Turn on debugging output for the given TOKEN(s). Without any tokens specified, it defaults to printing all the tokens (which is equivalent to the keyword “ALL”). You might want to tryALL for extremely verbose output. Note: You can not put a space between the -D flag and the listed TOKENs. -f Do not fork() from the calling shell. -g GID Change to the numerical group ID GID after opening listening sockets. -h, –help Display a brief usage message and then exit. -H Display a list of configuration file directives understood by the agent and then exit. -I [-]INITLIST Specifies which modules should (or should not) be initialized when the agent starts up. If the comma-separated INITLIST is preceded with a ‘-‘, it is the list of modules that should notbe started. Otherwise this is the list of the only modules that should be started.To get a list of compiled modules, run the agent with the arguments -Dmib_init -H (assuming debugging support has been compiled in). -L[efos] Specify where logging output should be directed (standard error or output, to a file or via syslog). See LOGGING OPTIONS in snmpcmd(5) for details. -m MIBLIST Specifies a colon separated list of MIB modules to load for this application. This overrides the environment variable MIBS. See snmpcmd(1) for details. -M DIRLIST Specifies a colon separated list of directories to search for MIBs. This overrides the environment variable MIBDIRS. See snmpcmd(1) for details. -n NAME Set an alternative application name (which will affect the configuration files loaded). By default this will be snmpd, regardless of the name of the actual binary. -p FILE Save the process ID of the daemon in FILE. -q Print simpler output for easier automated parsing. -r Do not require root access to run the daemon. Specifically, do not exit if files only accessible to root (such as /dev/kmem etc.) cannot be opened. -u UID Change to the user ID UID (which can be given in numerical or textual form) after opening listening sockets. -U Instructs the agent to not remove its pid file (see the -p option) on shutdown. Overrides the leave_pidfile token in the snmpd.conf file, see snmpd.conf(5). -v, –version Print version information for the agent and then exit. -V Symbolically dump SNMP transactions. -x ADDRESS Listens for AgentX connections on the specified address rather than the default “/var/agentx/master”. The address can either be a Unix domain socket path, or the address of a network interface. The format is the same as the format of listening addresses described below. -X Run as an AgentX subagent rather than as an SNMP master agent. –name=value Allows to specify any token (“name”) supported in the snmpd.conf file and sets its value to “value”. Overrides the corresponding token in the snmpd.conf file. See snmpd.conf(5) for the full list of tokens. SNMP服务自启动利用debian的systemd机制，编写snmpd.service文件(xxx.service是snmp依赖的服务,根据实际情况修改) 12345678910111213141516[Unit]Description=Simple Network Management Protocol (SNMP) DaemonAfter=syslog.target network.target xxx.serviceRequires=xxx.service[Service]Environment=LD_LIBRARY_PATH=/usr/libEnvironment=MIBDIRS=/usr/share/snmp/mibsType=simplePIDFile=/var/run/snmpd.pidExecStart=/bin/snmpd -f -c /etc/snmp/config/snmpd.conf -p /var/run/snmpd.pidRestart=on-failureRestartSec=3[Install]WantedBy=multi-user.target 执行enable命令 1$systemctl enable snmpd 系统下电重启，则SNMP服务会自动重新启动 其他控制操作1.启动 1$systemctl start snmpd 2.停止 1$systemctl stop snmpd 3.重启 1$systemctl restart snmpd 4.查询 1$systemctl status snmpd]]></content>
  </entry>
  <entry>
    <title><![CDATA[mib2c代码自动生成]]></title>
    <url>%2F2019%2F03%2F29%2Fmib2c%2F</url>
    <content type="text"><![CDATA[要使用mib2c工具自动生成Net-SNMP企业私有库代码，首先必须在开发环境中部署mib2c工具。该工具是net-snmp源码自带的，直接编译net-snmp源码后就可以使用了。 mib2c环境部署1.配置 1$./configure 2.编译 1$make 3.安装（如果没有在configure指定安装目录，则会安装到系统默认目录/usr/local/net-snmp） 1$make install mib2c生成代码1.设置环境变量，将需要生成代码的企业私有mib(xxx.mib)路径导出到环境变量 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/demo.mib 2.为leaf节点生成代码(xxx为demo.mib文件中modIdent节点名称) 1$/usr/local/net-snmp/bin/mib2c -c mib2c.scalar.conf xxx 3.为table节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.iterate.conf xxx 4.为notification节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.notify.conf xxx 在生成的代码中，添加自己的实现即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP的交叉编译 for ARM64]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp%2F</url>
    <content type="text"><![CDATA[1.交叉编译openssl去官网下载openssl-1.0.2q.tar.gz，解压缩到目录/home/lwang/work/chengw/github/下，然后进入openssl目录按照如下步骤操作 1) 配置编译选项 1$./config no-asm shared --cross-compile-prefix=aarch64-linux-gnu- --prefix=/home/lwang/work/chengw/github/openssl-1.1.1a/release 其中参数的含义为：no-asm：在交叉编译过程中不使用汇编代码代码加速编译过程；shared：生成动态链接库；–prefix：指定生成lib、include、bin三个核心目录的路径，不修改此项则默认为OPENSSLDIR目录。 2) 修改生成的Makefile，去掉-m64选项，否则会编译报错3) 编译 1$make -j4 4) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 2.交叉编译net-snmp在官网下载net-snmp-5.7.3.tar.gz，解压缩到/home/lwang/work/chengw/github/目录，然后进入net-snmp目录,并按照如下步骤操作 1) 配置编译选项 1$./configure --host=arm-linux --target=arm-linux --build=i686-linux --with-cc=aarch64-linux-gnu-gcc --with-ar=aarch64-linux-gnu-ar --prefix=/home/lwang/work/chengw/github/net-snmp-5.7.3/release --with-endianness=little --disable-manuals --disable-embedded-perl --disable-perl-cc-checks --without-perl-modules --disable-scripts --disable-applications --with-openssl=/home/lwang/work/chengw/github/openssl-1.0.2q/release 2) 编译 1$make -j4 3) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 注意：实际测试发现，net-snmp 5.7.3只能搭配openssl-1.0.2q版本使用，更新的版本会编译报错.]]></content>
  </entry>
</search>
