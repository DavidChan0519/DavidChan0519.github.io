<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gorm之model定义]]></title>
    <url>%2F2019%2F05%2F07%2Fgo-gorm-model%2F</url>
    <content type="text"><![CDATA[gorm的几个默认规则如下： 默认的表名是定义的结构体名称小写复数形式 1234type Usr struct &#123; UsrId int Name string&#125; 该结构体对应的默认表名就是usrs 12345678// 全局禁用表名复数，如果设置为true,则`Usr`的默认表名为`user`,db.SingularTable(true)//但是如果使用TableName()显示设置了表名，则最终的表名以设置的为准//如下：设置User的表名为`profiles`func (User) TableName() string &#123; return "profiles"&#125; 列名是字段名的蛇形小写 大小写字母之间用_间隔 12345678910111213type User struct &#123; ID uint // 列名为 `id` Name string // 列名为 `name` Birthday time.Time // 列名为 `birthday` CreatedAt time.Time // 列名为 `created_at`&#125;//通过tag重设列名type Animal struct &#123; AnimalId int64 `gorm:"column:beast_id"` // 设置列名为`beast_id` Birthday time.Time `gorm:"column:day_of_the_beast"` // 设置列名为`day_of_the_beast` Age int64 `gorm:"column:age_of_the_beast"` // 设置列名为`age_of_the_beast`&#125; 字段ID为默认主键1234567891011type User struct &#123; ID uint // 字段`ID`为默认主键 Name string&#125;// 使用tag`primary_key`用来设置主键type Animal struct &#123; AnimalId int64 `gorm:"primary_key"` // 设置AnimalId为主键 Name string Age int64&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[GORM之Automigrate]]></title>
    <url>%2F2019%2F05%2F06%2Fgorm-automigrate%2F</url>
    <content type="text"><![CDATA[gorm中的Automigrate()操作，其作用主要是刷新数据库中的表格，使其保持最新，即让数据库之前存储的记录的表格字段和程序中最新使用的表格字段保持一致（只增不减）。 以sqlite数据库存储为例(数据库文件查看，可以使用sqlite browser)： 第一次写入数据库的字段内容为 12345type Product struct &#123; gorm.Model Code string Price string&#125; 其在数据库的存储格式如下： 新增字段如果Product新增一个Age字段如下： 123456type Product struct &#123; gorm.Model Code string Price string Age string&#125; 调用automigrate后， 1db.AutoMigrate(&amp;Product&#123;&#125;) 数据库会自动为之前存储的item新增age字段，内容为空（NULL） 删除字段1234type Product struct &#123; gorm.Model Code string&#125; 调用Automigrate后，数据库之前记录的item保持不变，新增item只有Code一个column，price和age保持为空（NULL）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Golang之GORM框架的基本使用]]></title>
    <url>%2F2019%2F05%2F05%2Fgo-gorm-base%2F</url>
    <content type="text"><![CDATA[ORM（对象关系映射): 把数据库映射成对象。ORM 使用对象，封装了数据库操作，因此可以不碰 SQL 语言。开发者只使用面向对象编程，与数据对象直接交互，不用关心底层数据库实现； gorm是使用go语言实现数据库访问的ORM库。使用这个库，我们可以利用面向对象的方法，更加方便的对数据库中的数据进行CRUD(数据库的基本操作有四种：create、read、update和delete，简称 CRUD)，而无需关心底层数据库的具体实现以及数据库的类型(支持多种类型的数据库，例如MySQL，SQLite，PostgreSQL，MSSQL)。 基本使用:官方教程 下载依赖12$go get github.com/jinzhu/gorm$go get github.com/jinzhu/gorm/dialects/mysql 第一个是核心库。第二个是mysql数据库的驱动包，如果使用的是其他数据库，则需下载相应数据库的驱动包。 gorm包装了一些常用数据库的驱动，直接下载即可： 1234//import _ "github.com/jinzhu/gorm/dialects/mysql"//import _ "github.com/jinzhu/gorm/dialects/postgres"//import _ "github.com/jinzhu/gorm/dialects/sqlite"//import _ "github.com/jinzhu/gorm/dialects/mssql" 连接数据库12345678910111213141516171819202122232425262728293031packae mainimport ( "github.com/jinzhu/gorm" _ "github.com/jinzhu/gorm/dialects/mysql" "fmt")func main() &#123; db, err := gorm.Open("mysql","root:12345@/demo?charset=utf8&amp;parseTime=True&amp;loc=Local") if err != nil &#123; fmt.Println(err) return &#125; defer db.Close() // Migrate the schema db.AutoMigrate(&amp;Product&#123;&#125;) // Create db.Create(&amp;Product&#123;Code: "L1212", Price: 1000&#125;) // Read var product Product db.First(&amp;product, 1) // find product with id 1 db.First(&amp;product, "code = ?", "L1212") // find product with code l1212 // Update - update product's price to 2000 db.Model(&amp;product).Update("Price", 2000) // Delete - delete product db.Delete(&amp;product)&#125; 上面代码中 mysql 是数据库驱动，root 是数据库用户名，12345 是密码，demo 则是数据库名称。 新增数据12345678910type User struct &#123; gorm.Model ID int `gorm:"primary_key"` Name string `gorm:"not_null"`&#125;func add() &#123; user := &amp;User&#123;Name:"David"&#125; db.Create(user)&#125; User类型中内嵌了gorm.Model字段，gorm.Model会自动为User｛｝添加如下4个字段： id：索引 create_at：数据条目生成时间 updated_at：数据条目更新时间 deleted_at：数据条目删除时间 删除数据12user := &amp;User&#123;ID:1&#125;db.Delete(user) 更新数据12user := &amp;User&#123;ID:1&#125;db.Model(user).Update("Name","lisi") 查询数据123456789//查询所有条目var users []Userdb.Find(&amp;users)fmt.Println(users)//查询ID为1的条目user := new (User)db.First(user,1)fmt.Println(user) 其它:判断数据库中是否有结构体对应的表：1db.HasTable(User&#123;&#125;) 创建表1db.CreateTable(User&#123;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Goroutine]]></title>
    <url>%2F2019%2F04%2F30%2Fgoroutine-introduce%2F</url>
    <content type="text"><![CDATA[goroutine是go语言中的一种并发机制，实现简单，在需要异步执行的函数前加上go关键字即可，该函数即会异步执行。事实上，⼊⼝函数 main 就以 goroutine 运⾏。 但是需要⚠️的是：调度器不能保证多个 goroutine 执⾏次序，且进程退出时不会等待它们结束。所以这两点都需要在程序设计时从整体逻辑来考虑 123go func() &#123; println("Hello, World!")&#125;()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go接口的实现技巧]]></title>
    <url>%2F2019%2F04%2F30%2Fgo-interface-func%2F</url>
    <content type="text"><![CDATA[本文讲述一种比较少见的接口实现用法：用函数实现接口。 直接上代码： 1234567891011121314//Tester接口，包含Do()方法type Tester interface &#123; Do()&#125;type FuncDo func()//实现Do方法func (self FuncDo) Do() &#123; self() &#125;func main() &#123; var t Tester = FuncDo(func() &#123; println("Hello, World!") &#125;) t.Do()&#125; 输出： Hello, World! FuncDo类型实现了Do方法，所以可以将其赋值给Tester接口(该接口仅包含Do方法)。然后通过调用Tester接口类型t的方法来间接实现FuncDo函数Do方法的调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go空接口之类型转换]]></title>
    <url>%2F2019%2F04%2F29%2Fgo-empty-interface%2F</url>
    <content type="text"><![CDATA[话不多说，直接看代码 1234567891011121314type User struct &#123; id int name string&#125;func main() &#123; u := User&#123;1, "Tom"&#125; var i interface&#123;&#125; = u u.id = 2 u.name = "Jack" fmt.Printf("%v\n", u) fmt.Printf("%v\n", i.(User))&#125; 输出： 12&#123;2 Jack&#125;&#123;1 Tom&#125; 在赋值给空接口时，使用指针，再运行看下效果 12345678910111213type User struct &#123; id int name string&#125;func main() &#123; u := User&#123;1, "Tom"&#125; var vi, pi interface&#123;&#125; = u, &amp;u //copy u and assign to vi // vi.(User).name = "Jack" // Error: cannot assign to vi.(User).name pi.(*User).name = "Jack" fmt.Printf("%v\n", vi.(User)) fmt.Printf("%v\n", pi.(*User))&#125; 输出： 12&#123;1 Tom&#125;&amp;&#123;1 Jack&#125; 空接⼝转型返回临时对象（该临时对象的内存只能读，不能写），只有使⽤指针才能修改其状态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go方法集和方法表达式]]></title>
    <url>%2F2019%2F04%2F29%2Fgo-methods-expression%2F</url>
    <content type="text"><![CDATA[直接看代码 方法集： 1234567891011121314151617type User struct &#123; id int name string&#125;func (self User) Test() &#123; fmt.Println(self)&#125;func main() &#123; u := User&#123;1,"test"&#125; mValue := u.Test //⽴即复制 receiver，因为不是指针类型，不受后续修改影响 u.id, u.name = 2, "modified" u.Test() mValue()&#125; 输出： 12&#123;2 modified&#125;&#123;1 test&#125; 修改上述代码，将Test()方法的receiver类型改为指针 123func (self *User) Test() &#123; fmt.Println(self)&#125; 重新运行上述代码，输出： 12&#123;2 modified&#125;&#123;2 modified&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go中的数组]]></title>
    <url>%2F2019%2F04%2F28%2Fgo-array%2F</url>
    <content type="text"><![CDATA[go中的数组不同于c/c++中的数组，是值类型，在函数参数传递的时候，会拷贝整个数组(不同于c/c++中数组名相当于指针)。 数组的长度为const，当不指定长度时，类型变为切片（slice） 数组的几种初始化方式： 12345678910a := [3]int&#123;1, 2&#125; // 未初始化元素值为 0。b := [...]int&#123;1, 2, 3, 4&#125; // 通过初始化值确定数组⻓度。c := [5]int&#123;2: 100, 4:200&#125; // 使⽤索引号初始化元素。d := [...]struct &#123; name string age uint8&#125;&#123; &#123;"user1", 10&#125;, // 可省略元素类型。 &#123;"user2", 20&#125;, // 别忘了最后⼀⾏的逗号。&#125; 内置函数 len 和 cap 都返回数组⻓度 (元素数量)。 12a := [2]int&#123;&#125;println(len(a), cap(a)) // 2,2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go语言内置的所有数据类型]]></title>
    <url>%2F2019%2F04%2F28%2Fgo-all-data-type%2F</url>
    <content type="text"><![CDATA[列表为go内置的所有数据类型，包括基本数据类型，例如int，byte，rune，string；也有引用数据类型，例如slice，map，channel等；还有interface，函数等 如果想获取任何类型变量的存储地址，使用&amp;（取地址符） 12str := "you are my sunshine"fmt.Printf("addr:%p\n", &amp;str) 输出： 1addr:0xc0000621c0 字符串一旦创建不可修改，所以如果要修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。⽆论哪种转换，都会重新分配内存，并复制字节数组（本质上，修改后的字符串已不是原始的字符串，他们彼此占用了独立的内存空间）。 123456s := "abcd"b := []byte(s)b[0]='A'fmt.Printf("b:%s\n",b)fmt.Printf("s addr:%p\n",&amp;s)fmt.Printf("b addr:%p\n",&amp;b) 输出： 123b:Abcds addr:0xc000094010b addr:0xc000096000 Go 函数返回局部变量指针是安全的，不同于c/c++，编译器会根据需要，将该局部变量的内存分配在GC Heap上 123456789101112func main()&#123; p := test() fmt.Println("in main:",p) *p = 88 fmt.Printf("modified:%d\n",*p)&#125;func test() *int &#123; x := 100 fmt.Printf("local var addr:%p\n",&amp;x) return &amp;x&#125; 输出： 123local var addr:0xc000094000in main: 0xc000094000 //同一个空间modified:88 //可以访问返回的局部变量地址空间]]></content>
  </entry>
  <entry>
    <title><![CDATA[go语言中的interface类型]]></title>
    <url>%2F2019%2F04%2F25%2Fgo-interface%2F</url>
    <content type="text"><![CDATA[go语言中的interface类型，作用类似于c语言中的void指针。有着非常灵活的应用场景]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go可变参数函数]]></title>
    <url>%2F2019%2F04%2F23%2Fgo-variadic-param-func%2F</url>
    <content type="text"><![CDATA[可变参数函数即其参数数量是可变的 : 0 个或多个； 声明可变参数函数的方式是在其参数类型前面带上省略符（…）前缀。 一个简单的可变参数函数： 1234567func test(input …string) string &#123; return strings.Join(input,",")&#125;test("hello","world")test("single")test() 可变参数函数会在其内部创建一个”新的临时切片”。事实上，可变参数是一个简化了切片类型参数传入的语法糖。 当不传入参数的时候，可变参数会成为一个空值切片（ nil ) 当不太确定数据类型的时候我们通常采用空接口 interface{} 1234567tests1(789)fmt.Println("-------------")tests1("789")func tests1(arg interface&#123;&#125;) &#123; fmt.Println("value:", arg) fmt.Println("type:", reflect.TypeOf(arg).Name())&#125; 输出结果 12345value: 789type: int-------------value: 789type: string ⚠️在使用interface{}作为可变入参时，传入的参数要先做类型转换(先转换为[ ]interface{}) 1234567891011121314151617181920func testParams(args ...interface&#123;&#125;) &#123; for i, v := range args &#123; if s, ok := v.(string); ok &#123; fmt.Println("----", s) &#125; if s, ok := v.([]string); ok &#123; for i, v := range s &#123; fmt.Println(i, "[]----", v) &#125; &#125; fmt.Println(i, v) &#125;&#125;s := []string&#123;"4", "5", "6"&#125;var d []interface&#123;&#125;d = append(d, s)//或者//var d []interface&#123;&#125; = []interface&#123;&#125;&#123;s[0], s[1], s[2]&#125;testParams(d...) 结果: 12340 []---- 41 []---- 52 []---- 60 [4 5 6]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go中切片之间的浅拷贝和深拷贝]]></title>
    <url>%2F2019%2F04%2F22%2Fgo-slice-copy%2F</url>
    <content type="text"><![CDATA[我们知道，go语言中切片类型是从数组类型基础上发展出来的新类型，当声明一个数组时，不指定该数组长度，则该类型为切片(“动态数组”)，切片有自己独立的内部结构字段(len, cap, array pointer)，并共用底层数组空间。 例如： 12var s1 [10]int //数组var s2 []int //切片 切片属于引用类型，使用make分配内存空间和初始化成员结构。 12a := make([]int, 3) //长度为3b := make([]int, 3, 5) //长度为3，容量为5 切片字面量初始化： 数组到切片的拷贝(共享底层数组空间) 切片之间的拷贝分为2种：浅拷贝和深拷贝 浅拷贝：源切片和目的切片共享同一底层数组空间，源切片修改，目的切片同样被修改。 1234567891011package mainimport "fmt"func main()&#123; slice1 := make([]int, 5, 5) slice2 := slice1 slice1[1] = 1 fmt.Println(slice1) //[0 1 0 0 0] fmt.Println(slice2) //[0 1 0 0 0]&#125; 深拷贝：源切片和目的切片各自都有彼此独立的底层数组空间，各自的修改，彼此不受影响 12345678910111213141516171819package mainimport "fmt"func main()&#123; slice1 := make([]int, 5, 5) slice1[0]=9 slice2 := make([]int, 4, 4) slice3 := make([]int, 5, 5) //拷贝 fmt.Println(copy(slice2, slice1))//4 fmt.Println(copy(slice3, slice1))//5 //独立修改 slice2[1] = 2 slice3[1] = 3 fmt.Println(slice1)//[9 0 0 0 0 0] fmt.Println(slice2)//[9 2 0 0] fmt.Println(slice3)//[9 3 0 0 0]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[升级做爸爸了，开心]]></title>
    <url>%2F2019%2F04%2F17%2Fnew-son-new-life%2F</url>
    <content type="text"><![CDATA[内心憧憬了很久，一直心情很平静；但是当第一眼真正看到他的时候，内心还是受到了很大的冲击，眼里泛着泪花，激动的心情良久难以平复。哈哈，我可爱的儿子，我们终于见面了。辛苦妈妈十月怀胎，爸爸特此为你开一贴，感谢妈妈，以示纪念！ 我帅气的胖儿子]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建go程序源码编译环境]]></title>
    <url>%2F2019%2F04%2F11%2Fuse-softlink-for-go-build-env%2F</url>
    <content type="text"><![CDATA[编译go语言程序，需要将源码放在特定结构和目录名称的的工程环境中，并设置GOPATH环境变量. GOPATH最后一层目录名为src，同级的目录有bin，pkg目录，程序源码需要放在src下面。如下图所示： 但是通常我们在git代码库上提交的源码，并不一定是按照上述目录结构组织的。所以为了方便编译，而又不挪动源码，我们使用软链接的方法为需要编译的go源码搭建一个编译环境。 base_service工程中的Zeus是需要编译的go源码，在该目录中是无法直接使用go build命令进行编译的。 建立go编译工程目录：在外面任意位置新建编译目录build_go，里面分别建立src，bin，pkg等3个字目录 建立软连接:1$ln -sf /Users/bitmain/work/master/bitmain_gerrit/base_service/Zeus /Users/bitmain/work/master/bitmain_gerrit/go_build/src/Zeus 设置GOPATH环境变量:env.sh如下: 1$export GOPATH=$GOPATH:/Users/bitmain/work/master/bitmain_gerrit/go_build 编译：然后在go_build目录下执行编译脚本build.sh即可完成编译： 1234#!/bin/bashpushd /Users/bitmain/work/master/bitmain_gerrit/go_build/srcgo build -o zeus entry.gopopd]]></content>
  </entry>
  <entry>
    <title><![CDATA[python opencv图像金字塔]]></title>
    <url>%2F2019%2F04%2F10%2Fopencv-pyramid-sample%2F</url>
    <content type="text"><![CDATA[通俗点讲， 对一个图片进行金字塔操作，涉及如下两个函数； pyrDown( )函数的作用是向下采样并模糊一张图片，说白了就是缩小一张图片。 pyrUp( )函数的作用是向上采样并模糊一张图像，说白了就是放大一张图片； python示例代码： 1234567891011121314151617import cv2def pyramid(): img = cv2.imread('.\obma.jpg', cv2.IMREAD_COLOR) lower_reso1 = cv2.pyrDown(img) lower_reso2 = cv2.pyrDown(lower_reso1) lower_reso3 = cv2.pyrDown(lower_reso2) cv2.imshow('original', img) cv2.imshow('pyrdown1', lower_reso1) cv2.imshow('pyrdown2', lower_reso2) cv2.imshow('pyrdown3', lower_reso3) cv2.waitKey(0) cv2.destroyAllWindows()if __name__=='__main__': pyramid() 每调用一次pyrDown()操作，图片的H,W就减小至原来的一半。故面积缩小至原来的四分之一; 预览： pyrUp()相反，每调用一次，图片的H,W就增大至原来的2倍。故面积增大至原来的4倍; 需要注意的是，PryUp和PryDown不是互逆的，即PryUp不是降采样的逆操作。如果一张图片先调用pyrdown()一次，然后再调用pyrUp()，图片大小会恢复至原始大小，但是图像清晰度会下降。]]></content>
  </entry>
  <entry>
    <title><![CDATA[opencv python生成BGR三原色]]></title>
    <url>%2F2019%2F04%2F09%2Fcv2-bgr-sample%2F</url>
    <content type="text"><![CDATA[OpenCV能够处理图片的颜色通道顺序为为BGR（blue，green，red），即每个像素点由3个值组成，这3个值分别代表blue, green, red的值。 介绍一种简单的生成BGR三原色图片的方法。 原理：将另外两个通道的值置为0，本通道值置为255即可。 python示例如下： 123456789101112131415161718192021import cv2import numpy as npdef color(): blue = np.zeros([300,300,3],dtype='uint8') blue[:,:,0] = 255 green = np.zeros([300,300,3],dtype='uint8') green[:,:,1] = 255 red = np.zeros([300,300,3],dtype='uint8') red[:,:,2] = 255 cv2.imshow('blue',blue) cv2.imshow('green', green) cv2.imshow('red', red) cv2.waitKey(0) cv2.destroyAllWindows()if __name__=='__main__': color() 运行，预览：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数传递中的*号使用]]></title>
    <url>%2F2019%2F04%2F08%2Fpython-func-decompress-arglist%2F</url>
    <content type="text"><![CDATA[主要包含单引号和双引号的用法 单星号(*) 将所有参数以元组(tuple)的形式导入： 1234567&gt;&gt;&gt; def foo(param1, *param2): print param1 print param2&gt;&gt;&gt; foo('a',2,3,4,5)'a'(2, 3, 4, 5) 解压参数列表 123456&gt;&gt;&gt; def foo(param1, param2): print param1,param2&gt;&gt;&gt; input = [1,2]&gt;&gt;&gt; foo(*input)1,2 双引号(**) 将参数以字典(dict)的形式导入 1234567891011&gt;&gt;&gt; def foo(a, b=2, *args, **kwargs) print a print b print args print kwargs&gt;&gt;&gt; foo(1,23,3,4,e=5,f=6,g=7)123(3,4)&#123;'e':5,'f':6,'g':7&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go类型转换]]></title>
    <url>%2F2019%2F04%2F08%2Fgo-type-cast%2F</url>
    <content type="text"><![CDATA[Go语言不支持隐式类型转换，即使如下几种情况也不允许 同类型别名之间的转换123type INT intvar a INT = 10var b int = a // Error: ... 窄类型向宽类型转换12var b byte = 100var n int = b //Error: ... Go只支持显示类型转换 12var b byte = 10var n int = int(b)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac终端配色]]></title>
    <url>%2F2019%2F04%2F06%2Fmac-terminal-color%2F</url>
    <content type="text"><![CDATA[mac的terminal默认显示是灰白的，无法方便的区分普通文件，目录，可执行程序或者链接文件。本文介绍，借助于Coreutils工具模仿ubuntu的terminal默认配色，在mac terminal上还原ubuntu经典配色。 安装工具1$brew install coreutils 如果是因为无法翻墙的原因，可参考我上一篇文章中的方法-如何使terminal通过vpn联网 生成颜色定义文件1$gdircolors --print-database &gt; ~/.dir_colors 我们可以修改~/.dir_colors，添加自定义文件的颜色，此文件中的注释已经包含各种颜色取值的说明。 自定义文件颜色在~/.dir_colors尾部添加对各种源码文件及配置文件格式的支持 12345678910# code format.c 01;33.cpp 01;33.h 01;33.go 01;33.py 01;33.s 01;31.md 4;37.json 01;35.yml 01;35 添加启动配置在~/.bash_profile或者~/.bashrc配置文件中加入以下代码 12345if brew list | grep coreutils &gt; /dev/null ; then PATH="$(brew --prefix coreutils)/libexec/gnubin:$PATH" alias ls='ls -F --show-control-chars --color=auto' eval `gdircolors -b $HOME/.dir_colors`fi gdircolor的作用就是设置ls命令使用的环境变量LS_COLORS（BSD是LSCOLORS） 修改PS1，模拟ubuntu terminal prompt在~/.bash_profile或者~/.bashrc配置文件中加入以下代码，可以模拟Ubuntu terminal中prompt的配色 1export PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ ' 预览：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac终端通过VPN联网]]></title>
    <url>%2F2019%2F04%2F06%2Fmac-terminal-proxy%2F</url>
    <content type="text"><![CDATA[通常情况，mac链接vpn后，浏览器可以直接通过vpn联网；然而终端默认是不通过vpn的，所以对于程序员来说，这却是一个极大的不便利: 无法通过各种命令行工具下载文件，例如wget，curl，git get，apt-get等。 下面介绍一种简单的方法，使得terminal通过vpn联网 1$export http_proxy=http://proxyAddress:port vpn工具联网成功后，在terminal上执行上述命令，则可使的terminal通过vpn联网 该方法临时有效，退出终端后失效。如果希望保持一直有效，可将上述命令添加到~/.bashrc等启动配置文件中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go环境变量]]></title>
    <url>%2F2019%2F04%2F06%2Fgo-env%2F</url>
    <content type="text"><![CDATA[介绍几个go语言编程中常用的环境变量，都可以通过export指令修改 $GOROOT go编译器程序的安装目录 $GOPATH go项目工程的根目录 该目录下必须包含src，pkg，bin3个子目录 $GOBIN go程序编译完成后生成的可执行binary，使用go install命令时，自动安装到$GOPATH/bin下 $GOOS $GOARCH 目标平台的操作系统类型和芯片架构类型，这两个参数主要用于交叉编译中 go支持多种操作系统和芯片体系结构，故go对交叉编译也有很好的支持 使用如下命令可以查看当前环境中go相关的环境变量 1$go env Linux1234567891011121314151617181920212223242526GOARCH="amd64"GOBIN=""GOCACHE="/home/lwang/.cache/go-build"GOEXE=""GOFLAGS=""GOHOSTARCH="amd64"GOHOSTOS="linux"GOOS="linux"GOPATH="/home/lwang/go"GOPROXY=""GORACE=""GOROOT="/usr/local/go"GOTMPDIR=""GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64"GCCGO="gccgo"CC="gcc"CXX="g++"CGO_ENABLED="1"GOMOD=""CGO_CFLAGS="-g -O2"CGO_CPPFLAGS=""CGO_CXXFLAGS="-g -O2"CGO_FFLAGS="-g -O2"CGO_LDFLAGS="-g -O2"PKG_CONFIG="pkg-config"GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build193074853=/tmp/go-build -gno-record-gcc-switches" Mac1234567891011121314151617181920212223242526GOARCH="amd64"GOBIN=""GOCACHE="/Users/bitmain/Library/Caches/go-build"GOEXE=""GOFLAGS=""GOHOSTARCH="amd64"GOHOSTOS="darwin"GOOS="darwin"GOPATH="/Users/bitmain/go"GOPROXY=""GORACE=""GOROOT="/usr/local/go"GOTMPDIR=""GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"GCCGO="gccgo"CC="clang"CXX="clang++"CGO_ENABLED="1"GOMOD=""CGO_CFLAGS="-g -O2"CGO_CPPFLAGS=""CGO_CXXFLAGS="-g -O2"CGO_FFLAGS="-g -O2"CGO_LDFLAGS="-g -O2"PKG_CONFIG="pkg-config"GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/5x/6gkjj0_1581fwz9lvylk14mr0000gn/T/go-build089246083=/tmp/go-build -gno-record-gcc-switches -fno-common"]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go build模式之c-archive，c-shared，linkshared]]></title>
    <url>%2F2019%2F04%2F05%2Fgo-buildmode-c%2F</url>
    <content type="text"><![CDATA[本文用实例介绍这3种模式的构建方法； go程序中需要被导出的方法Hello()： 1234567891011121314//hello.gopackage mainimport "C"import "fmt"func main() &#123; Hello("hello")&#125;//export Hellofunc Hello(name string) &#123; fmt.Println("output:",name)&#125; 注意事项： 1.//export Hello，这是约定，所有需要导出给 C 调用的函数，必须通过注释添加这个构建信息，否则不会构建生成 C 所需的头文件; 2.导出函数的命名的首字母是否大写，不受go规则的影响，大小写均可; 3.头部必须添加import “C”; c-archive模式：1$go build --buildmode=c-archive hello.go 编译生成hello.a和C头文件hello.h 在所生成的 hello.h 的头文件中，我们可以看到 Go 的 Hello() 函数的定义： 123456789#ifdef __cplusplusextern "C" &#123;#endif...extern void Hello(GoString p0);...#ifdef __cplusplus&#125;#endif 在头文件中GoString的定义如下： 123456typedef struct &#123; const char *p; ptrdiff_t n; &#125; _GoString_;typedef _GoString_ GoString; 然后我们可以在 hello.c 中引用该头文件，并链接Go编译的静态库： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "hello.h"int main(int argc, char *argv[])&#123; char *type = argv[1]; char buf[] = "test for "; char input[16]=&#123;0&#125;; sprintf(input, "%s %s", buf, type); GoString str; str.p = input; str.n = strlen(input); Hello(str); return 0;&#125; 然后，构建 C 程序： 1$gcc -o hello_static hello.c hello.a -lpthread c-shared模式：1$go build --buildmode=c-shared -o libhello.so hello.go 编译生成libhello.so 构建c程序，并链接动态库 1$gcc -o hello_dynamic hello.c -L./ -lhello -lpthread -L 指定链接库为当前目录 -l 指定所需要连接的动态库名称，去掉lib前缀和.so后缀 linkshared模式： 该模式主要用于为go程序编译动态链接库 12$sudo /usr/local/go/bin/go install -buildmode=shared std$sudo /usr/local/go/bin/go build -linkshared -o hello_linkshared hello.go 编译生成hello_linkshared可执行程序 附上实例程序编译脚本 12345678910111213141516171819202122232425# !/bin/bash# staticgo build --buildmode=c-archive hello.gogcc -o hello_static hello.c hello.a -lpthreadecho "=== run static binary ==="./hello_static static# dynamicgo build --buildmode=c-shared -o libhello.so hello.gogcc -o hello_dynamic hello.c -L./ -lhello -lpthreadecho "=== run dynamic binary ==="./hello_dynamic dynamic# linkshared for gosudo /usr/local/go/bin/go install -buildmode=shared stdsudo /usr/local/go/bin/go build -linkshared -o hello_linkshared hello.goecho "=== run linkshared binary ==="ls -lh ./hello_linkshared./hello_linkshared# default , static for gogo build -o hello_static_go hello.gols -lh ./hello_static_go./hello_static_go 输出：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go简短模式声明变量之部分退化赋值]]></title>
    <url>%2F2019%2F04%2F04%2Fgo-short-assignment%2F</url>
    <content type="text"><![CDATA[golang 函数内定义变量，推荐使用简短模式，例如： 12x := 1y := "hello" 由于作用域的关系，该模式容易定义跟全局变量同名的函数局部新变量，使用的时候要特别小心。 12345678//全局变量xvar x = 100func main() &#123; //重新定义和初始化同名的局部变量x x := "abc" fmt.Println(x)&#125; 输出： 1abc 但是简短模式并不总是定义新变量，在重复使用的时候可能执行的是部分退化赋值操作 部分退化赋值的前提条件：最少有一个新变量被定义，且必须是在同一作用域 123456789101112package mainimport "fmt"func main() &#123; x := 100 fmt.Println("x:",x, " &amp;x:",&amp;x) fmt.Println("========== seperate ========") x , y := 200 , "abc" fmt.Println("x:",x, " &amp;x:",&amp;x) fmt.Println("y:",y, " &amp;y:",&amp;y)&#125; 输出： 1234x: 100 &amp;x: 0xc00006c080========== seperate ========x: 200 &amp;x: 0xc00006c080y: abc &amp;y: 0xc0000581c0 从输出结果可以看出，前后两次打印的x地址都是同一个，故可以说明前后两次x是同一个变量，仅仅是值发生了变化。 部分退化赋值这一特性可以用在处理函数错误返回值，允许重复使用err变量，非常方便 123456789101112131415161718package mainimport ( "gocv.io/x/gocv" "log")func main() &#123; val1, err := func1() if err != nil &#123; log.Fatal(err) &#125; ... val2, err := func2() if err != nil &#123; log.Fatal(err) &#125;&#125;]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go build模式]]></title>
    <url>%2F2019%2F04%2F04%2Fgo-build-mode%2F</url>
    <content type="text"><![CDATA[build mode: 用于指导编辑器如何创建可执行的二进制文件。越多的执行方式，就意味着可以让 Go 运行在更多的地方。 1$go build -buildmode=default goroutine_select.go 在编译go程序时，go编译器支持如下几种模式： 1234567891011121314151617181920212223242526272829303132333435363738-buildmode=archive Build the listed non-main packages into .a files. Packages named main are ignored.-buildmode=c-archive Build the listed main package, plus all packages it imports, into a C archive file. The only callable(可调用的) symbols will be those functions exported using a cgo //export comment. Requires exactly one main package to be listed.-buildmode=c-shared Build the listed main package, plus all packages it imports, into a C shared library. The only callable symbols will be those functions exported using a cgo //export comment. Requires exactly one main package to be listed.-buildmode=default Listed main packages are built into executables and listed non-main packages are built into .a files (the default behavior).-buildmode=shared Combine all the listed non-main packages into a single shared library that will be used when building with the -linkshared option. Packages named main are ignored.-buildmode=exe Build the listed main packages and everything they import into executables. Packages not named main are ignored.-buildmode=pie Build the listed main packages and everything they import into position independent executables (PIE). Packages not named main are ignored.-buildmode=plugin Build the listed main packages, plus all packages that they import, into a Go plugin. Packages not named main are ignored. 解释： 12345678exe: 静态编译exe: 动态链接 libcexe: 动态链接 libc 和非 Go 代码pie: 地址无关的可执行文件(安全特性)c-archive: C 的静态链接库c-shared: C 的动态链接库shared: Go 的动态链接库plugin: Go 的插件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go多变量赋值]]></title>
    <url>%2F2019%2F04%2F03%2Fgo-multi-assign%2F</url>
    <content type="text"><![CDATA[Go语言支持一次定义多个变量，同时也支持多个变量赋值。 例如： 1var x , y = "abc", 100 多变量赋值 原则1：要优先计算所有相关值，然后再从左到右依次赋值 123data , i := []int&#123;1,2,3&#125;, 1i , data[i] = 2, 100fmt.Println(i, data) 输出结果： 12 [1,100,3] i本身的值为1，在被赋值为2之前，data[i] -&gt; data[1] 优先，所以i=2， data[1] = 100 原则2：要优先计算出所有右值，然后再从左到右依次赋值 123x, y := 1, 2x, y = y+3, x+2println(x,y) 输出： 15,3]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GoCV进行人脸检测]]></title>
    <url>%2F2019%2F04%2F03%2Fgocv-face-detection%2F</url>
    <content type="text"><![CDATA[示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( "fmt" "gocv.io/x/gocv" "image" "image/color" "log")func main() &#123; webCam , err := gocv.VideoCaptureDevice(0) if err != nil &#123; log.Fatal(err) &#125; defer webCam.Close() window := gocv.NewWindow("face") defer window.Close() img := gocv.NewMat() defer img.Close() classifier := gocv.NewCascadeClassifier() defer classifier.Close() if !classifier.Load("/data/haarcascade_frontalface_default.xml") &#123; log.Fatal("load model failed\n") &#125; for &#123; if ok := webCam.Read(&amp;img); !ok &#123; log.Fatalln("read img from webcam failed") &#125; if img.Empty() &#123; continue &#125; rects := classifier.DetectMultiScale(img) fmt.Printf("found %d face\n",len(rects)) for _ , ret := range rects &#123; color := color.RGBA&#123;0,0,225,0&#125; gocv.Rectangle(&amp;img, ret, color,3) size := gocv.GetTextSize("human",gocv.FontHersheyPlain, 1.2, 2) pt := image.Pt(ret.Min.X+(ret.Min.X/2)-(size.X/2), ret.Min.Y-2) gocv.PutText(&amp;img, "Human", pt, gocv.FontHersheyPlain, 1.2, color, 2) &#125; window.IMShow(img) if window.WaitKey(1) &amp; 0xff == int('q') &#123; break &#125; &#125;&#125; 编译 1$go build test_face_detection.go 执行结果： 按q键，退出]]></content>
  </entry>
  <entry>
    <title><![CDATA[GoCV：使用Go和OpenCV4.0.1进行计算机视觉编程]]></title>
    <url>%2F2019%2F04%2F03%2Fgocv-introduction%2F</url>
    <content type="text"><![CDATA[To use GoCV, you must install OpenCV 4.0.1 on your system. Linux环境安装 Mac 环境安装 示例代码： This example opens a video capture device using device “0”, reads frames, and shows the video in a GUI window: 12345678910111213141516package mainimport ( "gocv.io/x/gocv")func main() &#123; webcam, _ := gocv.VideoCaptureDevice(0) window := gocv.NewWindow("Hello") img := gocv.NewMat() for &#123; webcam.Read(&amp;img) window.IMShow(img) if (window.WaitKey(1) &amp; 0xff == int('q') &#123; break &#125; &#125;&#125; 编译程序，并执行 12$go build -o test_cv gocv_example.go$./test_cv 如果执行过程出现如下错误： 1./test_cv: error while loading shared libraries: libopencv_calib3d.so.4.0: cannot open shared object file: No such file or directory 解决办法： 1$export LD_LIBRARY_PATH=/home/chengwei/work/github/opencv-4.0.1/release/lib:$LD_LIBRARY_PATH 执行效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用clion编译c++程序报错]]></title>
    <url>%2F2019%2F04%2F02%2Fclion-compile-err%2F</url>
    <content type="text"><![CDATA[问题描述：Clion编译c++程序，报错 “wchar.h not found” 12345678/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h:119:15:** **fatal error:** 'wchar.h' file not found**\#include_next &lt;wchar.h&gt;^~~~~~~~~1 error generated.make[2]: *** [CMakeFiles/test_virtual.bin.dir/test_virtual.cpp.o] Error 1make[1]: *** [CMakeFiles/test_virtual.bin.dir/all] Error 2make: *** [all] Error 2 解决办法：click “Tools -&gt; CMake -&gt; ResetCache and Reload Project” 重新编译即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Dockerfile中使用COPY指令]]></title>
    <url>%2F2019%2F04%2F02%2Fdockerfile-copy%2F</url>
    <content type="text"><![CDATA[COPY指令:1COPY &lt;src&gt; &lt;dest&gt; 我们在使用dockerfile构建docker镜像时，通常会用到COPY指令。COPY指令用于将系统本地的文件拷贝至docker镜像中。但是其中有一个地方需要特别注意：即build上下文. 在使用 docker build 命令通过 Dockerfile 创建镜像时，会产生一个 build 上下文(context)。所谓的 build 上下文就是 docker build 命令的 PATH 或 URL 指定的路径中的文件的集合。在镜像 build 过程中可以引用上下文中的任何文件，比如我们要介绍的 COPY 命令，就可以引用上下文中的文件。 默认情况下 docker build -t custom . 命令中的 . 表示build上下文为当前目录。 当然我们可以指定一个目录作为上下文，比如： 1$docker build -t custom /home/linaro 注意事项：在使用COPY指令时，本地的源文件要位于build上下文中。 如果build上下文是当前目录，则源文件要位于dockerfile所在的当前目录。 例如： 12WORKDIR /workCOPY snmp . snmp目录要位于dockerfile所在的目录中 否则build过程中会报错：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git for Gerrit 客户端配置指导]]></title>
    <url>%2F2019%2F04%2F02%2Fgit-and-gerrit-guide%2F</url>
    <content type="text"><![CDATA[Install and config Gitinstall git1$sudo apt-get install git config git1$git config --global user.name "Your Name" 1$git config --global user.email "your.email@gmail.com" Note：”Your Name” must be same with your domain name, for example wei.cheng Check config information1$git config --list Generate and upload ssh keyOn Linux 1$ssh-keygen -t rsa -C "your.email@gmail.com" Don’t use any passphrase 1$vim ~/.ssh/config 123456----------------------------------------------------------------Host * KexAlgorithms +diffie-hellman-group1-sha1---------------------------------------------------------------- 1$cat ~/.ssh/id_rsa.pub Copy the whole file into clipboardOpen gerrit website , On website, goto “Settings -&gt; SSH Public Keys”, paste the key, press “Add” Clone projects12345678910111213141516$git clone &lt;ssh://your.name@gerrit.ai.bmfusion.net:29418/xxx.git&gt;$git submodule init$git submodule update --rebase --remote$git fetch origin$git rebase origin/master#Do merge if needed, after solving conflict, run$git rebase --continue#Amend the previous change if needed$git commit --amend#Push$git push origin HEAD:refs/for/master]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV源码编译安装]]></title>
    <url>%2F2019%2F04%2F02%2Fopencv-src-compile%2F</url>
    <content type="text"><![CDATA[从官网下载最新版4.0.1源码，解压缩，并按以下步骤执行： 进入源码目录1$cd opencv-4.0.1 创建编译目录build，使用cmake进行源码外编译 如果系统没有安装cmake工具，请先安装cmake 1$mkdir build 进入编译目录1$cd build 配置 指定编译后lib文件和头文件的安装路径为/usr/local，默认生成pkgconfig文件，编译python2&amp;3接口 1$cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_GENERATE_PKGCONFIG=ON -D BUILD_opencv_python2=ON -D BUILD_opencv_python3=ON ../ 编译 j值为CPU核数 1$make -j4 安装1$sudo make install 注：如果cmake配置增加 -D BUILD_opencv_world=ON 选项编译，会将所有动态库融合为一个动态库opencv_world.so 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go编程语法注意事项]]></title>
    <url>%2F2019%2F04%2F01%2Fgo-syntax%2F</url>
    <content type="text"><![CDATA[看完《Go语言实战》和《Go核心编程》这两本教程，自己总结了一些使用Go编程的要领和注意事项 使用 := 赋值操作符，这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明； 全局变量允许声明但不使用，但是局部变量声明后不使用，则编译会报错； 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，但是两个变量的类型必须相同； Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑； 字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组； 获取字符串中某个字节的地址的行为是非法的，例如： 12str := "hello world"&amp;str[i] switch语句case中不需要break来结束; 未初始化的map的值是nil。map默认是无序的,既不是按照key的顺序排列，也不是按照value排序的; 无论是结构体还是结构体指针类型，都使用点号来获取结构体字段（不同于C/C++，指针使用-&gt;来获取成员变量）; 如果File是一个结构体类型，那么表达式 12new(File)&amp;File&#123; &#125; 是等价的 在一个结构体中,对于每一种数据类型只能有一个匿名字段; 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法，比较类似于面向对象里面的继承; 空接口： type Any interface{ }，不实现任何方法，所以任何类型都实现了空接口. 可以给一个空接口类型的变量赋任何类型的值， 每个空接口类型变量占用2个字节：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针,空接口类似于C语言的*void指针； 复制数据切片至空接口切片必须逐一赋值，因为内存布局不一样； 结构struct中只有被导出字段（首字母大写）才是可设置的； 实际上，反射是通过检查一个接口的值，变量首先被转换成空接口； 类型可以通过内嵌多个接口来提供像多重继承一样的特性； 函数重载通过空接口实现； 封装：1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见；2）可导出的：通过标识符首字母大写，对象对所在包以外也可见； 继承： 用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现； 多态： 用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现； 字节切片初始化方式： 1）圆括号会进行类型转换；2）花括号则直接赋值； 当调用panic时，所有的defer语句都会保证执行，并把控制权交还给panic的函数调用者； panic会导致栈被展开直到defer修饰的recover()被调用或者程序中止，recover只能在defer修饰的函数； 执行go test用于测试单个文件时，一定要后跟被测试的源代码文件，如果原文件有其他的引用，有需要一并跟上，否则会提示引用找不到的错误； 协程工作在相同的地址空间，所以共享内存的方式一定是同步的；协程是轻量的，比线程更轻; 经验法则，对于n个核心的情况设置GOMAXPROCS 为n-1以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1+GOMAXPROCS &gt; 1； 如果在某一时间只有一个协程在执行，不要设置GOMAXPROCS！ GOMAXPROCS等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行； 协程会随着程序的结束而自动消亡； 协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序； 通道只能传输一种类型的数据, 所有的类型都可以用于通道，空接口interface{}也可以。甚至可以（有时非常有用）创建通道的通道； 一个无缓冲通道只能包含1个元素, 带缓冲的通道包含多个元素； 关闭通道： 只有发送者才需要关闭通道，接收者不需要关闭通道； 所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名； import导入包时，如果包名前有下划线_，表示初始化该包，但是不是用包里的变量； 程序中每个代码文件里的 init 函数都会在 main 函数执行前调用； 包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其其包中的代码直接访问； 包名应该使用全小写命名 如果使用 … 替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度； 如果在[ ]运算符里指定了一个值，那么创建的就是数组而不是切片。只有为空的时候，才会创建切片； nil切片不同于空切片, 成员指针变量的值不一样，前者值为nil，后者值为0； 切片赋值，共享底层数组； 如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改； 在函数间传递切片，就是要在函数间以值的方式传递切片，这里值传递是指的拷贝地址，实际的切片元素值是不用拷贝的； 在64位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节； 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组，值传递； 用type声明的新类型与原类型是两个完全不同的类型，不能互相赋值； go语言里面有两种类型的接受者（1-值接收者；2-指针接收者） 两种类型的方法，可以彼此互相调用; 值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法(方法对值的修改会影响实际值)。 在实际编写代码时，还要看值类型，是否方便复制（如果值中包含未公开类型，则不能复制） 接口： 用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现； 123type Maker interface &#123; Make()&#125; 当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见 带缓冲的通道，当主动close通道后，goroutine依然可以从通道接收数据，但是不能再往通道发送数据了 iota的使用，默认为0，逐步递增； 字符串类型在 go里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节 在定义常量组时，如果不提供初始值，则表示将使用上一行的表达式； 123456789const ( Sunday = 0 Monday Tuesday Wednesday Thursday Friday Saturday) Sunday为0，其他常量均为0 可以通过将非可变参数置于可变参数前面的方式来混合使用它们，注意：非可变参数只能放在可变参数前面； 使用os.Exit(0)函数退出程序，之前声明的defer函数不会执行； go语言有指针，但是没有指针运算，不能对指针进行偏移； 初始化顺序： 全局变量 -&gt; init() -&gt; main()； package 基本的管理单元：同一个package下面，可以有非常多的不同文件，只要每个文件的头部 都有 如 “package xxx” 的相同name, 表示这些文件属于同一个包； import导入包滥用时，可能会存在循环依赖的问题，需要主动避免； 空切片和nil切片是两个完全不同的概念；nil切片：只声明，不做初始化空切片：声明后初始化为空]]></content>
  </entry>
  <entry>
    <title><![CDATA[上传Docker镜像到私有镜像仓储]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-priv-repo-setup%2F</url>
    <content type="text"><![CDATA[出于信息安全，版本控制等因素考虑，自己搭建docker镜像仓储（搭建教程本文不介绍），可以方便有效的管理大量本地的docker镜像。本文主要介绍如何上传本地的docker镜像到自己搭建的私有镜像仓储 配置本地docker在 /etc/docker/daemon.json（如果没有该文件，则可创建一个） 填入如下字段: 12345&#123; "insecure-registries":[ "10.30.37.149:6000" ]&#125; 10.30.37.149为自己搭建的docker镜像仓储服务器IP，6000为服务器开放的端口 然后执行以下命令重新启动docker 1$sudo systemctl reload docker 如果不做以上配置，push镜像的时候会报以下错误：http: server gave HTTP response to HTTPS client 给需要上传的镜像打tag1$sudo docker tag 3dbe0975429e 10.30.37.149:6000 /bm1682_debian:1.1.1 3dbe0975429e 为本地需要上传的镜像的IMAGE ID， tag格式：私有镜像仓储服务器IP:端口/镜像名称:版本号 上传镜像到私有仓储1$sudo docker push 10.30.37.149:6000/bm1682_debian:1.1.1 下载私有仓储的镜像到本地1sudo docker pull 10.30.37.149:6000/bm1682_debian:1.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 容器端口映射方法]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-port-expose%2F</url>
    <content type="text"><![CDATA[docker容器在启动的时候，如果不指定端口映射参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 现在有如下两种方式导出端口： 启动容器的时候通过-P，-p或者–expose参数动态指定： 端口映射支持的格式 ip : host port : container port #指定宿主机ip、指定宿主机port、指定容器 ip :: container port #指定ip、指定容器port host port : container port #指定宿主机port、指定容器port 1$docker run -P -it ubuntu /bin/bash 以上指令会将容器暴露的所有端口，都随机映射到宿主机上(不推荐) 1$docker run -P 80 -it ubuntu /bin/bash 以上指令会将容器的80端口随机映射到宿主机的一个端口上 1$docker run -p 8000:80 -it ubuntu /bin/bash 以上指令会将容器的80端口映射到宿主机的8000端口上 1$docker run -P 192.168.0.100::80 -it ubuntu /bin/bash 以上指令会将容器的IP 192.168.0.100和80端口，映射到宿主机的8000端口 1docker run -p 1000-2000:1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，映射到宿主机端口1000-2000 1$docker run --expose=1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，随机映射到宿主机端口上 在Dockerfile里面通过EXPOSE指令静态配置：EXPOSE指令只是指定暴露容器内部端口，映射规则还需要在运行容器时通过-P参数指定 1234567891011# GET_IMAGEFROM centos# MAINTAINER_INFOMAINTAINER hongxue hongxue@showjoy.comRUN yum -y install vim# PORTEXPOSE 8080EXPOSE 22 上述Dockerfile暴露了容器内的8080和22两个端口给宿主机。 运行容器时，通过增加-P参数，Docker会自动为用户创建端口映射规则，并且帮助避免端口映射的冲突，这两个端口会被随机映射到宿主机上的两个端口上， 1$docker run -d -it -P --name container_name image_name EXPOSE指令也支持指定端口范围 1EXPOSE 7000-8000 查看指定容器端口映射配置:示例： 12$docker port container_ID ``#容器ID80/tcp -&gt; 0.0.0.0:800]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP ARM部署]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp-deployment%2F</url>
    <content type="text"><![CDATA[交叉编译 net-snmp交叉编译，生成snmpd 交叉编译企业私有节点动态库 libbmserv.so 简单版配置文件snmpd.conf1234567891011121314151617181920212223242526272829############################################################################ snmpd.conf###########################################################################dlmod bmserv /usr/lib/libbmserv.so#v1/v2crocommunity rrrrrrwcommunity wwww#v1 traptrapsink 10.30.33.2 rrrrr#v2c traptrap2sink 10.30.33.2 rrrrr#v2c informinformsink 10.30.33.2 rrrrr#v3engineIDType 3rouser rouser privcreateUser rouser MD5 11111111 DES 22222222rwuser rwuser privcreateUser rwuser MD5 33333333 DES 44444444# v3 traptrapsess -v 3 -u rouser -a MD5 -A 11111111 -x DES -X 22222222 -l priv 192.168.1.111 engineType. 1|2|3 : SNMP v3的安全配置，engine id的产生依赖于此选项自动生成； 配置了该选项，就不需要在trapsess选项中通过-e参数来手动指定engine id，否则就需要. specifies that the engineID should be built from the IPv4 address (1), IPv6 address (2) or MAC address (3). Note that changing the IP address (or switching the network interface card) may cause problems. ARM部署将snmpd，libbmserv.so，snmpd.conf及相关的net-snmp库文件打包，然后放到arm开发环境。 snmpd一般放在/bin目录下，snmpd.conf一般放在/etc/snmp/config目录下(没有的话，可自己建立相应的目录) libbmserv.so及net-snmp的动态库文件都可以放在/usr/local/lib下，私有mib文件及公共mib文件都放在/usr/share/mibs下，通过MIBS环境变量指定路径 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/Bitmain.mib 手动启动1$snmpd -f -c /etc/snmp/config/snmpd.conf 全部可选参数如下： OPTIONS -a Log the source addresses of incoming requests. -A Append to the log file rather than truncating it. 默认每次重新启动snmpd，snmpd.log会被清理掉以便重新记录日志，之前旧的日志会被丢弃; 添加-A选项后，旧日志被保留，新的日志追加在旧的日志尾部 -c FILE Read FILE as a configuration file (or a comma-separated list of configuration files). Note that the loaded file will only understand snmpd.conf tokens, unless the configuration type is specified in the file as described in the snmp_config man page under SWITCHING CONFIGURATION TYPES IN MID-FILE. -C Do not read any configuration files except the ones optionally specified by the -c option. Note that this behaviour also covers the persistent configuration files. This may result in dynamically-assigned values being reset following an agent restart, unless the relevant persistent config files are explicitly loaded using the -c option. -d Dump (in hexadecimal) the sent and received SNMP packets. -D[TOKEN[,…]] Turn on debugging output for the given TOKEN(s). Without any tokens specified, it defaults to printing all the tokens (which is equivalent to the keyword “ALL”). You might want to tryALL for extremely verbose output. Note: You can not put a space between the -D flag and the listed TOKENs. -f Do not fork() from the calling shell. -g GID Change to the numerical group ID GID after opening listening sockets. -h, –help Display a brief usage message and then exit. -H Display a list of configuration file directives understood by the agent and then exit. -I [-]INITLIST Specifies which modules should (or should not) be initialized when the agent starts up. If the comma-separated INITLIST is preceded with a ‘-‘, it is the list of modules that should notbe started. Otherwise this is the list of the only modules that should be started.To get a list of compiled modules, run the agent with the arguments -Dmib_init -H (assuming debugging support has been compiled in). -L[efos] Specify where logging output should be directed (standard error or output, to a file or via syslog). See LOGGING OPTIONS in snmpcmd(5) for details. -m MIBLIST Specifies a colon separated list of MIB modules to load for this application. This overrides the environment variable MIBS. See snmpcmd(1) for details. -M DIRLIST Specifies a colon separated list of directories to search for MIBs. This overrides the environment variable MIBDIRS. See snmpcmd(1) for details. -n NAME Set an alternative application name (which will affect the configuration files loaded). By default this will be snmpd, regardless of the name of the actual binary. -p FILE Save the process ID of the daemon in FILE. -q Print simpler output for easier automated parsing. -r Do not require root access to run the daemon. Specifically, do not exit if files only accessible to root (such as /dev/kmem etc.) cannot be opened. -u UID Change to the user ID UID (which can be given in numerical or textual form) after opening listening sockets. -U Instructs the agent to not remove its pid file (see the -p option) on shutdown. Overrides the leave_pidfile token in the snmpd.conf file, see snmpd.conf(5). -v, –version Print version information for the agent and then exit. -V Symbolically dump SNMP transactions. -x ADDRESS Listens for AgentX connections on the specified address rather than the default “/var/agentx/master”. The address can either be a Unix domain socket path, or the address of a network interface. The format is the same as the format of listening addresses described below. -X Run as an AgentX subagent rather than as an SNMP master agent. –name=value Allows to specify any token (“name”) supported in the snmpd.conf file and sets its value to “value”. Overrides the corresponding token in the snmpd.conf file. See snmpd.conf(5) for the full list of tokens. SNMP服务自启动利用debian的systemd机制，编写snmpd.service文件(xxx.service是snmp依赖的服务,根据实际情况修改) 12345678910111213141516[Unit]Description=Simple Network Management Protocol (SNMP) DaemonAfter=syslog.target network.target xxx.serviceRequires=xxx.service[Service]Environment=LD_LIBRARY_PATH=/usr/libEnvironment=MIBDIRS=/usr/share/snmp/mibsType=simplePIDFile=/var/run/snmpd.pidExecStart=/bin/snmpd -f -c /etc/snmp/config/snmpd.conf -p /var/run/snmpd.pidRestart=on-failureRestartSec=3[Install]WantedBy=multi-user.target 执行enable命令 1$systemctl enable snmpd 系统下电重启，则SNMP服务会自动重新启动 其他控制操作1.启动 1$systemctl start snmpd 2.停止 1$systemctl stop snmpd 3.重启 1$systemctl restart snmpd 4.查询 1$systemctl status snmpd]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP企业节点动态库编辑]]></title>
    <url>%2F2019%2F03%2F29%2Fenterprise-priv%2F</url>
    <content type="text"><![CDATA[查阅net-snmp的相关资料，目前Net-SNMP有多种使用方式。本文只介绍snmpd + 企业私有节点动态库的方式。目前这种方式也在多数企业中得到广泛使用。使用这种方式的优点：不用修改net-snmp源码；第一次交叉编译net-snmp生成snmpd后，后面新增feature，修复bug等不需要重新编译net-snmp源码，仅仅维护企业节点动态库就可以了。 企业节点动态库初始化函数在使用mib2c工具自动生成相应代码后，还需要在代码中添加一个启动函数，该启动函数是snmpd守护进程调用企业节点动态库的入口： 123void init_bmserv(void)｛ ...｝ 该函数bmserv的命名应同生成的动态库名称libbmserv.so要保持一致 Makefile交叉编译动态库，模版makefile如下(根据实际环境进行修改适配)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#************************************************************# 通用Makefile#************************************************************CC = aarch64-linux-gnu-gcc#************************************************************# 编译选项#************************************************************# 宏定义选项MACRO_FLAGS := # 使用到的库，只要写lib后的名称，不用加.so或.aLIB_FLAGS := curl crypto cjson# 编译.c到.o文件的选项CC_FLAGS := -Wall -fPIC# 连接.o文件用到的选项LINK_FLAGS := -Wall -fPIC -lpthread -shared#************************************************************# 源代码目录#************************************************************ROOT := $(shell pwd)SRCDIRS := $(ROOT)# ************************************************************# 头文件目录# ************************************************************INCLUDE_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/include/#************************************************************# 动态库、静态库目录#************************************************************LIB_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/openssl/lib/arm64/#************************************************************# 最终生成的程序名称#************************************************************TARGET := libbmserv.so#************************************************************# 被编译的.c文件#************************************************************SRC_C := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))#************************************************************# 所有的.o文件#************************************************************OBJ_C := $(notdir $(patsubst %.c, %.o, $(SRC_C)))#************************************************************# 编译规则#************************************************************.PHONY: all cmd_init cmd_last cleanall:cmd_init $(TARGET) cmd_last# 编译前命令cmd_init: @echo "SRC DIR:" $(SRCDIRS) @echo cmd_init# 编译后命令cmd_last: @echo cmd_lastVPATH = $(SRCDIRS)$(TARGET):$(OBJ_C) $(CC) $(LINK_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) $(LIB_DIRS:%=-L%) -o $@ $^ $(LIB_FLAGS:%=-l%) $(OBJ_C):%.o:%.c $(CC) $(CC_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) -c -o $@ $&lt;clean: rm -f *.o rm -f $(TARGET) 编译 1$make 即可在当前目录下生成企业私有节点动态库libbmserv.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[mib2c代码自动生成]]></title>
    <url>%2F2019%2F03%2F29%2Fmib2c%2F</url>
    <content type="text"><![CDATA[要使用mib2c工具自动生成Net-SNMP企业私有库代码，首先必须在开发环境中部署mib2c工具。该工具是net-snmp源码自带的，直接编译net-snmp源码后就可以使用了。 mib2c环境部署1.配置 1$./configure 2.编译 1$make 3.安装（如果没有在configure指定安装目录，则会安装到系统默认目录/usr/local/net-snmp） 1$make install mib2c生成代码1.设置环境变量，将需要生成代码的企业私有mib(xxx.mib)路径导出到环境变量 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/demo.mib 2.为leaf节点生成代码(xxx为demo.mib文件中modIdent节点名称) 1$/usr/local/net-snmp/bin/mib2c -c mib2c.scalar.conf xxx 3.为table节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.iterate.conf xxx 4.为notification节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.notify.conf xxx 在生成的代码中，添加自己的实现即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP的交叉编译 for ARM64]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp%2F</url>
    <content type="text"><![CDATA[1.交叉编译openssl去官网下载openssl-1.0.2q.tar.gz，解压缩到目录/home/lwang/work/chengw/github/下，然后进入openssl目录按照如下步骤操作 1) 配置编译选项 1$./config no-asm shared --cross-compile-prefix=aarch64-linux-gnu- --prefix=/home/lwang/work/chengw/github/openssl-1.1.1a/release 其中参数的含义为：no-asm：在交叉编译过程中不使用汇编代码代码加速编译过程；shared：生成动态链接库；–prefix：指定生成lib、include、bin三个核心目录的路径，不修改此项则默认为OPENSSLDIR目录。 2) 修改生成的Makefile，去掉-m64选项，否则会编译报错3) 编译 1$make -j4 4) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 2.交叉编译net-snmp在官网下载net-snmp-5.7.3.tar.gz，解压缩到/home/lwang/work/chengw/github/目录，然后进入net-snmp目录,并按照如下步骤操作 1) 配置编译选项 1$./configure --host=arm-linux --target=arm-linux --build=i686-linux --with-cc=aarch64-linux-gnu-gcc --with-ar=aarch64-linux-gnu-ar --prefix=/home/lwang/work/chengw/github/net-snmp-5.7.3/release --with-endianness=little --disable-manuals --disable-embedded-perl --disable-perl-cc-checks --without-perl-modules --disable-scripts --disable-applications --with-openssl=/home/lwang/work/chengw/github/openssl-1.0.2q/release 2) 编译 1$make -j4 3) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 注意：实际测试发现，net-snmp 5.7.3只能搭配openssl-1.0.2q版本使用，更新的版本会编译报错.]]></content>
  </entry>
</search>
