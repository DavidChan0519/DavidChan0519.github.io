<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BeyondCompare4注册失效解决办法]]></title>
    <url>%2F2019%2F06%2F04%2Fbeyondcompare4-crack%2F</url>
    <content type="text"><![CDATA[启动Beyond Compare4，弹出Revoked错误提示。 解决办法：把C:\Users[用户名]\AppData\Roaming\Scooter Software\Beyond Compare 4文件夹下的全部文件删除，然后重新启动，重新输入注册码即可 注意： 如果找不到AppData文件， 可能是文件夹被隐藏了，按照下面的顺序打开即可请查看工具—&gt;文件夹选项—&gt;查看—&gt;高级设置—&gt;显示隐藏的文件即可。 分享一个Beyond Compare4的注册码 (如有经济能力，请支持正版)： 1234567891011121314Beyond Compare 4Licensed to: ASIO AllsoftinoneQuantity: 1 userSerial number: 1822-9597License type: Pro Edition for Windows--- BEGIN LICENSE KEY ---H1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpU-pFB9GmyPk677gJvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZt-xVrVU27+0JahFbqTmYskatMTgPyjvv99CF2Te8ec+Ys2SPxyZAF0YwOCNOWmsyqN5y9tq2Kw2pjoiDs5gIH-uw5U49JzOB6otS7kThBJE-H9A76u4uUvR8DKb+VcBrWu5qSJGEnbsXNfJdq5L2D8QgRdV-sXHp2A-7j1X2n4WIISvU1V9koIySNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi+7oUSqebX+--- END LICENSE KEY ----- 复制上面的内容，直接粘贴到注册框内.]]></content>
  </entry>
  <entry>
    <title><![CDATA[SCP传输文件免输入密码]]></title>
    <url>%2F2019%2F05%2F31%2Fscp-no-password%2F</url>
    <content type="text"><![CDATA[通常我们会使用scp命令在多个服务器之间互相传输文件。使用过程中，需要正确输入目标机器的密码，否则传输失败。频繁的输入密码会带来工作效率的低下，尤其是当密码很复杂的时候，会令人抓狂。 scp命令格式： 1$scp [可选参数] file1 [file2] [file3] usrname@xx.xx.xx.xx:/pwd 在需要经常互相拷贝文件的机器上预设密码，可以免去每次操作都要输入密码的苦恼。 下面通过示例，从A机器拷贝文件到B机器，来介绍使用方式： 步骤1：在A机器上，执行以下命令 12$cd ~/.ssh/$ssh-keygen -t rsa 生成id_rsa和id_rsa.pub这两个文件，如果此前这两个已经存在，则不需要执行上述命令。 将id_rsa.pub拷贝到名为authorized_keys的文件中 1$cat id_rsa.pub &gt; authorized_keys 步骤2：将authorized_keys拷贝到B机器的~/.ssh目录，此时scp还是需要输入密码的 1$scp authorized_keys lwang@10.31.33.41:/home/lwang/.ssh 拷贝成功后，后面再使用scp命令从A拷贝文件到B机器，就无需输入密码了。该方式同样对ssh登陆有效，以后从A机器ssh登陆B机器，也无需输入密码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[nohup-后台运行命令]]></title>
    <url>%2F2019%2F05%2F31%2Fnohup-introduction%2F</url>
    <content type="text"><![CDATA[linux后台运行程序的两种方式： $command &amp; ： 后台运行，你关掉终端会停止运行； $nohup command &amp; ： 后台运行，你关掉终端也会继续运行； nohup 命令介绍 :用途：Linux命令用法，不挂断地运行命令。 语法：nohup Command [ Arg … ] [ &amp; ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 &amp; （ 表示“and”的符号）到命令的尾部。 如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 退出状态：126 : 可以查找但不能调用 Command 参数指定的命令。127 : nohup 命令发生错误或不能查找由 Command 参数指定的命令。 否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。 该命令的一般形式为：nohup command &amp; 如果使用nohup命令提交作业，在缺省情况下该作业的所有输出都被重定向到当前目录一个名为nohup.out的文件中，除非另外指定了输出文件，例如下面这个命令： 1$nohup command &gt; log.file 2&gt;&amp;1 &amp; 该命令输出被重定向到log.file文件中。 1$nohup python yourscript.py &amp; 该命令可以让你的python程序在后台运行，控制台输出导向到nohup.out文件 注意事项：关于nohup启动python程序输出缓存问题：python的输出有缓冲，导致nohup.out并不能够马上看到输出。 添加-u 参数，使得python不启用缓冲。 1$nohup python -u flush.py &amp; 关于退出问题：在nohup执行成功后直接点击关闭程序按钮关闭终端，会断掉该命令对应的session，导致nohup对应的进程被通知一起shutdown。所以在使用nohup命令后台运行命令之后，需要使用exit正常退出当前账户，而不能直接关闭终端，这样才能保证命令一直在后台运行]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++成员函数指针]]></title>
    <url>%2F2019%2F05%2F27%2Fcplus-mem-func-ptr%2F</url>
    <content type="text"><![CDATA[类成员函数指针（member function pointer），是C++语言的一类指针数据类型，用于存储一个指定类)具有给定的形参列表与返回值类型的成员函数的访问信息。 要注意两点： ①函数指针赋值要使用 &amp; ②使用.*(实例对象)或者-&gt;*（实例对象指针）调用类成员函数指针所指向的函数 非静态的成员方法函数指针语法：void (*ptrStaticFun)() = &amp;ClassName::staticFun; 成员方法函数指针语法：void (ClassName::*ptrNonStaticFun)() = &amp;ClassName::nonStaticFun;注意调用类中非静态成员函数的时候，使用的是 类名::函数名，而不是 实例名::函数名。 示例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# include &lt;stdio.h&gt;# include &lt;iostream&gt;using namespace std;class MyClass &#123;public: static int FunA(int a, int b) &#123; cout &lt;&lt; "call FunA" &lt;&lt; endl; return a + b; &#125; void FunB() &#123; cout &lt;&lt; "call FunB" &lt;&lt; endl; &#125; void FunC() &#123; cout &lt;&lt; "call FunC" &lt;&lt; endl; &#125; int pFun1(int (*p)(int, int), int a, int b) &#123; return (*p)(a, b); &#125; void pFun2(void (MyClass::*nonstatic)()) &#123; (this-&gt;*nonstatic)(); &#125;&#125;;int main() &#123; MyClass m; MyClass* obj = new MyClass; // 静态函数指针的使用 int (*pFunA)(int, int) = &amp;MyClass::FunA; cout &lt;&lt; pFunA(1, 2) &lt;&lt; endl; // 成员函数指针的使用 void (MyClass::*pFunB)() = &amp;MyClass::FunB; (obj-&gt;*pFunB)(); m.*pFunB(); // 通过 pFun1 只能调用静态方法 obj-&gt;pFun1(&amp;MyClass::FunA, 1, 2); // 通过 pFun2 就是调用成员方法 obj-&gt;pFun2(&amp;MyClass::FunB); obj-&gt;pFun2(&amp;MyClass::FunC); delete obj; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++作用域限定符“::”]]></title>
    <url>%2F2019%2F05%2F23%2Fcplus-scope-qualifier%2F</url>
    <content type="text"><![CDATA[“ :: “是作用域限定符(field qualifier)或称作用域运算符，用它声明函数是属于哪个类的. 如果在作用域运算符“::”的前面没有类名，或者函数名前面既无类名又无作用域运算符“::”，如 12::display( )display( ) 则表示display函数不属于任何类，这个函数不是成员函数，而是全局函数，即非成员函数的一般普通函数。作用在于区分同名的全局变量（或函数）和局部变量（或函数） 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int sum=0;int main()&#123; int n,a[N],sum=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(i%2==0) sum+=a[i]; ::sum+=a[i]; &#125; cout&lt;&lt;"all="&lt;&lt;::sum&lt;&lt;' '&lt;&lt;"odd="&lt;&lt;sum; return 0;&#125; 全局变量sum用来求数组的全部和，局部变量sum用来求奇数小标元素的和。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ typedef typename的作用]]></title>
    <url>%2F2019%2F05%2F22%2Fc-typedef-typename%2F</url>
    <content type="text"><![CDATA[c++的一个语法： 1typedef typename std::vector&lt;T&gt;::size_type size_type; 将typedef和typename关键字联用。 1234567template &lt;class T,class Alloc=alloc&gt;class vector&#123;public://...typedef size_t size_type;//...&#125;; 从vector的类定义可以看出，vector::size_type是vector嵌套类型定义，其实际等价于 size_t类型。 123vector&lt;int&gt;::size_type ssize;//就等价于size_t ssize; 为什么要在typedef后面加上typename关键字？ 原因： 实际上，模板类型在实例化之前，编译器并不知道vector&lt;T&gt;::size_type是什么东西，事实上一共有三种可能： 静态数据成员静态成员函数嵌套类型 那么此时typename的作用就在此时体现出来了——定义就不再模棱两可。 typedef创建了存在类型的别名，而typename告诉编译器std::vector&lt;T&gt;::size_type是一个类型而不是一个成员。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac开启sshd服务]]></title>
    <url>%2F2019%2F05%2F21%2Fmac-sshd-service%2F</url>
    <content type="text"><![CDATA[默认情况，mac自身的sshd服务是没有开启的，需要手动开启。 开启该服务后，则可远程ssh到mac，进行相关的操作。 操作步骤：启动sshd服务：1$sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist 停止sshd服务：1$sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist 查看状态：1$sudo launchctl list | grep ssh 如果看到下面的输出表示成功启动了： －－－－－－－－－－－－－－ - 0 com.openssh.sshd ssh连接1$ssh localhost 输入用户名和密码，则可连接成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[远程拷贝命令-rsync]]></title>
    <url>%2F2019%2F05%2F17%2Frsync-cmd%2F</url>
    <content type="text"><![CDATA[在linux下，我们习惯使用scp命令来远程拷贝文件，非常方便，但是这个命令在拷贝过程中存在一个问题，即如果目录中存在软链接，使用scp拷贝就会导致软链接失效（解决办法：将需要拷贝的目录先打包，使用scp拷贝到目标机器后，在目标机器上解包）。而使用rsync命令拷贝，则可以规避这一问题。 Rsync命令常用参数：1`-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD``-``v``, --verbose 详细模式输出``-p, --perms 保持文件权限``-g, --group 保持文件属组信息``-o, --owner 保持文件属主信息``-r, --recursive 对子目录以递归模式处理。同步目录的时候要加上这个参数``-l, --links 保留软链结，加上这个参数，同步过来的文件会保持之前的软链接属性不变``-H, --hard-links 保留硬链结``-e, --rsh=COMMAND 指定使用rsh、``ssh``方式进行数据同步``-z, --compress 对备份的文件在传输时进行压缩处理``--stats 给出某些文件的传输状态``--progress 打印同步的过程``--timeout=TIME 同步过程中，IP超时时间，单位为秒``--delete 删除那些目标目录中有而源目录中没有的多余文件。这个是``rsync``做增量方式的全备份的最佳选择方案！！！！！！``--delete-before 接受者在输出之前进行删除操作。即先将目标目录中文件全部删除，再将源目录文件拷贝过去。这是``rsync``保持目标目录跟源目录一致的方案！！！``--delete-after 在同步操作之后做比较，删除那些目标目录中有而源目录中没有的多余文件``--delete-excluded 删除目标目录中那些被该选项指定排除的文件``--ignore-errors 即使出现IO错误也进行删除，忽略错误``--exclude 指定同步时需要过滤掉的文件或子目录(即不需要同步过去的)，后面直接跟不需要同步的单个文件名或子目录(不需要跟路径) ，过滤多个文件或子目录，就使用多个--exclude``--exclude-from 指定同步时需要过滤掉的文件或子目录，后面跟文件(比如``/root/exclue``.txt)，然后将不需要同步的文件和子目录放到``/root/exclue``.txt下。``--version 打印版本信息``--port=PORT 指定其他的``rsync``服务端口``--log-``format``=formAT 指定日志文件格式``--password-``file``=FILE 从FILE中得到密码``--bwlimit=KBPS 限制I``/O``带宽，KBytes per second` 从命令参数中可以看到，使用参数-l可以保持软链接不失效 1$rsync -l -r --progress bm_prebuilt_toolchains lwang@10.31.33.41:/home/lwang/work/project/ 同时，rsync命令对于增量拷贝，也是非常有效，减少拷贝时间]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go数组初始化-指定元素值]]></title>
    <url>%2F2019%2F05%2F15%2Fgo-array-specified-elem%2F</url>
    <content type="text"><![CDATA[在Go语言中数组是一个值类型（value type）。是真真实实的数组，而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化，这一点严重不同于C语言。所有的值类型变量在赋值和作为参数传递时都将产生一次复制动作。如果将数组作为函数的参数类型，则在函数调用时该参数将发生数据复制。因此，在函数体中无法修改传入的数组的内容，因为函数内操作的只是所传入数组的一个副本。 定义方式如下 1var arr [n]type n表示数组长度，type表示数组存储类型。 下面实例中列举了几种常用的数组初始化方法，尤其是需要注意省略号，冒号等使用的方式 1234567891011121314package mainimport "fmt"func main()&#123; var arr1 [5]int arr2 := [5]int&#123;1, 2, 3, 4, 5&#125; //指定长度为5，并赋5个初始值 arr3 := [5]int&#123;1, 2, 3&#125; //指定长度为5，对前3个元素进行赋值，其他2个元素为零值 arr4 := [5]int&#123;4: 1&#125; //指定长度为5，对第5个元素(下标为4)赋值 arr5 := [...]int&#123;1, 2, 3, 4, 5&#125; //不指定长度，对数组赋以5个值 arr6 := [...]int&#123;8: 1&#125; //不指定长度，对第9个元素（下标为8）赋值1 fmt.Println(arr1, arr2, arr3, arr4, arr5, arr6)&#125; 输出： 1[0 0 0 0 0] [1 2 3 4 5] [1 2 3 0 0] [0 0 0 0 1] [1 2 3 4 5] [0 0 0 0 0 0 0 0 1]]]></content>
  </entry>
  <entry>
    <title><![CDATA[linux history命令显示时间戳]]></title>
    <url>%2F2019%2F05%2F15%2Flinux-shell-history-env%2F</url>
    <content type="text"><![CDATA[使用 HISTTIMEFORMAT 显示时间戳 当你从命令行执行 history 命令后，通常只会显示已执行命令的序号和命令本身。如果你想要查看命令历史的时间戳，那么可以执行： 123456# export HISTTIMEFORMAT=&apos;%F %T &apos;# history | more1 2008-08-05 19:02:39 service network restart2 2008-08-05 19:02:39 exit3 2008-08-05 19:02:39 id4 2008-08-05 19:02:39 cat /etc/redhat-release 注意：这个功能只能用在当 HISTTIMEFORMAT 这个环境变量被设置之后，之后的那些新执行的 bash 命令才会被打上正确的时间戳。在此之前的所有命令，都将会显示成设置 HISTTIMEFORMAT 变量的时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vmware workstation扩展linux客户机系统磁盘空间的方法-gparted]]></title>
    <url>%2F2019%2F05%2F15%2Fvm-linux-space-extend%2F</url>
    <content type="text"><![CDATA[扩展前： 扩展后： 前后对比，可以看出，根目录/ 空间增加了100GB。使用率从扩展之前的96%降到了目前的35%，够继续使用一段时间了，后面如果空间不够，可以继续用该方法进行扩展。 操作步骤：客户机关机； 选择 VMware的虚拟机-&gt;设置-&gt;硬盘(SCSI)-&gt;磁盘实用工具-&gt;扩展磁盘容量将磁盘空间大小调整为合适的值，一定需要比原来的大，我这里调整为160GB（原来为60GB），最后确定. 启动客户机，安装磁盘分区工具 1$apt-get install gparted 从窗口启动图形化分区工具Gparted 将之前extend分区删掉，不删的话无法重置sda1主分区大小（右键swapoff -&gt; 右键delete） 调整/dev/sda1的大小为158GB，预留2GB做swap分区，再次新建一个extend分区，然后在extend分区下在建一个swap逻辑分区，点击上方绿色的对号保存即可。 至此，扩展空间就完成了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux下LIBRARY_PATH和LD_LIBRARY_PATH环境变量的区别]]></title>
    <url>%2F2019%2F05%2F14%2Flinux-library-env-diff%2F</url>
    <content type="text"><![CDATA[LIBRARY_PATH环境变量：用于在程序编译期间查找动态链接库时，指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）： 1$export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH LD_LIBRARY_PATH环境变量：用于在程序加载运行期间查找动态链接库时，指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。 设置方法如下（其中，LIBDIR3和LIBDIR4为两个库目录）： 1$export LD_LIBRARY_PATH=LIBDIR3:LIBDIR4:$LD_LIBRARY_PATH 区别与使用： 编译时，设置LIBRARY_PATH，以便gcc能够找到编译时需要的动态链接库。 运行时，设置LD_LIBRARY_PATH，以便程序加载运行时能够自动找到需要的动态链接库。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统opencv多版本共存]]></title>
    <url>%2F2019%2F05%2F14%2Fopencv-multi-support%2F</url>
    <content type="text"><![CDATA[背景： 假如ubuntu系统中之前已经安装好2.4.13版本的opencv，但是项目需要使用4.1版本的opencv，在不影响已经安装的opencv版本的前提下，按照如下方法设定环境变量，即可解决两个版本在同一个系统中共存的问题。 4.1版本的opencv源码编译后，安装在~/work/github/opencv-4.1/release目录,避免安装到默认路径，造成多版本混乱: 目录结构如下: 1234567release|-- bin|-- include|-- lib`-- share4 directories, 0 files 指定头文件路径：1$export CPLUS_INCLUDE_PATH=~/work/github/opencv-4.1/release/include/opencv4/:$CPLUS_INCLUDE_PATH 指定查找头文件的路径 指定CMake库路径：1$export PKG_CONFIG_PATH=/home/chengwei/work/github/opencv-4.1/release/lib/pkgconfig:$PKG_CONFIG_PATH cmake通过find_package( )才能找到相应的库 指定编译链接库路径：1$export LIBRARY_PATH=/home/chengwei/work/github/opencv-4.1/release/lib:$LIBRARY_PATH 此处要注意LIBRARY_PATH和LD_LIBRARY_PATH环境变量的区别，前者用于编译，后者用于运行时链接 指定运行链接库路径：1$export LD_LIBRARY_PATH=/home/chengwei/work/github/opencv-4.1/release/lib:$LD_LIBRARY_PATH 通过设定上述环境变量，即可让项目在编译和链接时，使用4.1版本的opencv头文件和动态库]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go-protobuf插件安装]]></title>
    <url>%2F2019%2F05%2F14%2Fprotoc-gen-go%2F</url>
    <content type="text"><![CDATA[按照如下结构搭建go编译环境 1234567chengwei@ubuntu:/mnt/hgfs/win_share/test/go$ tree -L 1.|-- bin|-- pkg|-- src3 directories 首先配置GOPATH环境变量： 12$export GOPATH=/mnt/hgfs/win_share/test/go:$GOPATH$export GOBIN=/mnt/hgfs/win_share/test/go/bin 在go编译环境中执行如下命令，下载go protobuf源码 1$go get -u github.com/golang/protobuf/protoc-gen-go 执行上述命令后，在bin目录就已经安装好protoc-gen-go，该软件为protoc的插件，用于将proto生成go源码($GOPATH/bin 应该被加入 PATH 环境变量，以便 protoc 能够找到 protoc-gen-go) 1$protoc --go_out=. *.proto 生成的go源码都是以.pb.go结尾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Protobuf源码编译安装(C++)]]></title>
    <url>%2F2019%2F05%2F13%2Fprotocol-buffer-base%2F</url>
    <content type="text"><![CDATA[下载源码 1$git clone https://github.com/protocolbuffers/protobuf.git 执行以下命令编译安装 123$ cd protobuf$ git submodule update --init --recursive$ ./autogen.sh protobuf支持多种语言，例如C++, GO, Python, JAVA, PHP, JavaScript 下面介绍安装c++版本的protobuf runtime和protoc 12345$ ./configure$ make$ make check$ sudo make install$ sudo ldconfig # refresh shared library cache. 默认情况下，编译结果会安装到 /usr/local目录下，如果想安装到其他位置，可以在configure时指定 1./configure --prefix=/xxx 安装结束后，查看版本号，以确认是否安装成功 1$protoc -v 输出结果： libprotoc 3.7.1 至此，protobuf就安装成功了]]></content>
  </entry>
  <entry>
    <title><![CDATA[go test之httptest]]></title>
    <url>%2F2019%2F05%2F10%2Fgo-test-httptest%2F</url>
    <content type="text"><![CDATA[在使用go语言进行编程的时候，go test命令方便的让我们进行函数单元测试。 1$go test -v 但是当被测试函数依赖于环境(读取硬件路由表)或者server端实现(发送http请求给server端)，本地运行go test执行单元测试就会出现问题。这就需要我们在本地测试代码中将待测试函数中依赖外部的实现部分进行打桩（返回构造的假结果）。 本文以http请求为例，使用httptest包代替server端，构造http返回结果。 目录结构： peron.go文件，待测函数GetInfo( ) 1234567891011121314151617181920212223242526272829303132333435363738package personimport ( "encoding/json" "fmt" "io/ioutil" "net/http")type Person struct &#123; Name string `json:"name"` Address string `json:"address"` Age int `json:"age"`&#125;func GetInfo(api string, addr string) ([]Person, error) &#123; url := fmt.Sprintf("%s/person?addr=%s", api, addr) resp, err := http.Get(url) if err != nil &#123; return []Person&#123;&#125;, err &#125; if resp.StatusCode != http.StatusOK &#123; return []Person&#123;&#125;, fmt.Errorf("get info didn’t respond 200 OK: %s", resp.Status) &#125; body, err := ioutil.ReadAll(resp.Body) if err != nil &#123; return nil, fmt.Errorf("read response failed") &#125; p := make([]Person,0) err = json.Unmarshal(body,&amp;p) if err != nil &#123; return nil, fmt.Errorf("unmarshal response failed") &#125; return p, nil&#125; peron_test.go文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package personimport ( "encoding/json" "fmt" "net/http" "net/http/httptest" "testing")var personResponse = []Person&#123; &#123; Name : "wahaha", Address : "shanghai", Age : 20, &#125;, &#123; Name : "lebaishi", Address : "shanghai", Age : 10, &#125;,&#125;var personResponseBytes, _ = json.Marshal(personResponse)func TestPublishWrongResponseStatus(t *testing.T) &#123; ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123; w.WriteHeader(http.StatusOK) w.Write(personResponseBytes) if r.Method != "GET" &#123; t.Errorf("Expected 'GET' request, got '%s'", r.Method) &#125; if r.URL.EscapedPath() != "/person" &#123; t.Errorf("Expected request to '/person', got '%s'", r.URL.EscapedPath()) &#125; r.ParseForm() topic := r.Form.Get("addr") if topic != "shanghai" &#123; t.Errorf("Expected request to have 'addr=shanghai', got: '%s'", topic) &#125; &#125;)) defer ts.Close() api := ts.URL fmt.Println("url:", api) resp, err := GetInfo(api, "shanghai") if err != nil &#123; fmt.Println("ERROR:", err.Error()) t.Error(err) &#125; else &#123; fmt.Println("Rsp:", resp) &#125;&#125;func TestPublishWrongResponseStatusWithFailed(t *testing.T) &#123; ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) &#123; w.WriteHeader(http.StatusBadRequest) w.Write(personResponseBytes) if r.Method != "GET" &#123; t.Errorf("Expected 'GET' request, got '%s'", r.Method) &#125; if r.URL.EscapedPath() != "/person" &#123; t.Errorf("Expected request to '/person', got '%s'", r.URL.EscapedPath()) &#125; r.ParseForm() topic := r.Form.Get("addr") if topic != "shanghai" &#123; t.Errorf("Expected request to have 'addr=shanghai', got: '%s'", topic) &#125; &#125;)) defer ts.Close() api := ts.URL fmt.Println("url:", api) resp, err := GetInfo(api, "not_shanghai") if err != nil &#123; fmt.Println("ERROR:", err.Error()) &#125; else &#123; fmt.Println("Rsp:", resp) &#125;&#125; 在person目录下执行测试命令: 1$go test -v 输出： 1234567891011=== RUN TestPublishWrongResponseStatusurl: http://127.0.0.1:44973Rsp: [&#123;wahaha shanghai 20&#125; &#123;lebaishi shanghai 10&#125;]--- PASS: TestPublishWrongResponseStatus (0.00s)=== RUN TestPublishWrongResponseStatusWithFailedurl: http://127.0.0.1:45683--- FAIL: TestPublishWrongResponseStatusWithFailed (0.00s) person_test.go:69: Expected request to have 'addr=shanghai', got: 'not_shanghai'FAILexit status 1FAIL person 0.009s]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++ vector排序实例]]></title>
    <url>%2F2019%2F05%2F10%2Fc-sort-example%2F</url>
    <content type="text"><![CDATA[话不多说，直接上c++代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//// Created by chengw on 2019-05-09.//#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int score;&#125;;bool More(const student &amp;a, const student &amp;b)&#123; return a.score &gt; b.score;&#125;bool Less(const student &amp;a, const student &amp;b)&#123; return a.score &lt; b.score;&#125;int main()&#123; int N,type; cout &lt;&lt; "Please input nums and order:(1-increase;0-decrease)" &lt;&lt; endl; while (cin &gt;&gt; N &gt;&gt; type)&#123; vector&lt;student&gt; s(N); cout &lt;&lt; "name:" &lt;&lt; " score:" &lt;&lt; endl; for(int i=0; i &lt; N; i++)&#123; cin &gt;&gt; s[i].name &gt;&gt; s[i].score; &#125; cout &lt;&lt; "after sort:" &lt;&lt; endl; if(type == 0) stable_sort(s.begin(), s.end(), More); //稳定排序 else stable_sort(s.begin(), s.end(), Less); for(int i = 0; i &lt; N; i ++)&#123; cout &lt;&lt; s[i].name &lt;&lt; " " &lt;&lt; s[i].score &lt;&lt; endl; &#125; &#125; return 0;&#125; 编译后，执行输出： 123456789101112131415Please input nums and order:(0-increase;1-decrease)5 1name: score:a 98b 78c 99d 100e 67after sort:e 67b 78a 98c 99d 100]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go权限控制]]></title>
    <url>%2F2019%2F05%2F08%2Fgo-rights-control%2F</url>
    <content type="text"><![CDATA[Go是以首字母大小写来区分是公有还是私有，但都是针对包级别的。无论首字母大写还是小写，在包内所有的都能访问。该规则适用于变量，常量，方法，结构体成员。 方法绑定本身只能绑定包内的类型，所以方法可以访问接收者所有成员。如果是包外调用某类型的方法，则需要看方法名首字母是大写还是小写，首字母大写能被包外访问，小写则只能被包内访问。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu显示屏幕旋转]]></title>
    <url>%2F2019%2F05%2F08%2Fubuntu-display-rotate%2F</url>
    <content type="text"><![CDATA[为了方便竖屏显示，可以执行如下命令进行屏幕旋转 1234$ xrandr -o left 向左旋转90度$ xrandr -o right 向右旋转90度$ xrandr -o inverted 上下翻转$ xrandr -o normal 回到正常角度 通常情况下，从默认横屏显示转换到竖屏显示，只需要执行第一个命令即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go之判断struct类型是否实现某接口]]></title>
    <url>%2F2019%2F05%2F07%2Fgo-interface-implement%2F</url>
    <content type="text"><![CDATA[给出一段示例代码，主要演示如何判断某struct类型是否实现了某接口 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "reflect")type Tester interface &#123; Do() string&#125;type User struct &#123; Name string Age int &#125;func (self User) Do() string &#123; return "do it"&#125;func main() &#123; var u User t := reflect.TypeOf(u) //将nil转成Tester接口指针，然后再通过反射,Elem()方法获取指针对应的接口类型 fmt.Println(reflect.TypeOf((*Tester)(nil)).Elem().String()) if t.Implements(reflect.TypeOf((*Tester)(nil)).Elem()) &#123; fmt.Println("Support !!!") &#125;&#125; 输出： 12main.TesterSupport !!! 本文中比较难理解的一个点就是需要将nil转换成接口指针类型 (接口也是go中的一个数据类型，和其他类型int，string一样，也是存在对应的指针类型的)，然后通过反射获取该接口指针类型的类型，最后通过Element()方法获取指针对应的接口类型。之所以要这么做的原因是，无法直接获取接口的类型。 尝试如下操作，获取Tester接口的类型： 12var intf Tester //nil接口reflect.Typeof(intf) 也尝试过直接将nil转成Tester接口，然后通过反射获取类型 1reflect.TypeOf(Tester(nil)) 将上述结果作为参数传递给Implement()，都会报如下错误： 1panic: reflect: nil type passed to Type.Implements 这是因为上述两种方法通过反射获取的类型都为nil]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go示例-通过reflect遍历struct的所有方法]]></title>
    <url>%2F2019%2F05%2F07%2Fgo-reflect-example%2F</url>
    <content type="text"><![CDATA[本文通过一个示例程序，主要展示如何通过reflect来遍历一个struct的所有方法，仅供参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package mainimport ( "fmt" "reflect")type Usr struct &#123; Id int Name string&#125;func (Usr) TableName() string &#123; fmt.Println("value method doing ...return string") return "selfName"&#125;func (Usr) TableId() int &#123; fmt.Println("value method doing ...return int") return 7&#125;func (*Usr) Test() &#123; fmt.Println("pointer method doing ...no return") return&#125;func main() &#123; u := Usr&#123;Id:007,Name:"James"&#125; //循环遍历接收者为值的所有方法 for i, n := 0, reflect.TypeOf(u).NumMethod(); i &lt; n; i++ &#123; fmt.Printf("-------------- %d(%d) --------------\n",i,n) r := Exec(u,i) v := reflect.TypeOf(r).Kind() switch v &#123; case reflect.Int: fmt.Println("result:",r.(int)) case reflect.String: fmt.Println("result:",r.(string)) default: fmt.Println("no result return") &#125; &#125; fmt.Println("\n============== seperator ============\n") //循环遍历接收者为指针的所有方法 for i, n := 0, reflect.TypeOf(&amp;u).NumMethod(); i &lt; n; i++ &#123; fmt.Printf("-------------- %d(%d)--------------\n",i,n) r := Exec(&amp;u,i) if r != nil &#123; v := reflect.TypeOf(r).Kind() switch v &#123; case reflect.Int: fmt.Println("result:",r.(int)) case reflect.String: fmt.Println("result:",r.(string)) default: fmt.Println("invalid result return") &#125; &#125; &#125;&#125;//调用receiver的所有方法(包含receiver为值和指针的所有方法)func Exec(obj interface&#123;&#125;, idx int) interface&#123;&#125; &#123; t := reflect.TypeOf(obj) r := t.Method(idx).Func.Call([]reflect.Value&#123;reflect.ValueOf(obj)&#125;) valNum := len(r) if valNum != 0 &#123; mid := r[0].Interface() v := reflect.TypeOf(mid) switch v.Kind() &#123; case reflect.String: return mid.(string) case reflect.Int: return mid.(int) default: return nil &#125; &#125;else &#123; return nil &#125;&#125; 输出： ————– 0(2) ————–value method doing …return intresult: 7————– 1(2) ————–value method doing …return stringresult: selfName ============== seperator ============ ————– 0(3)————–value method doing …return intresult: 7————– 1(3)————–value method doing …return stringresult: selfName————– 2(3)————–pointer method doing …no return]]></content>
  </entry>
  <entry>
    <title><![CDATA[gorm之model定义]]></title>
    <url>%2F2019%2F05%2F07%2Fgo-gorm-model%2F</url>
    <content type="text"><![CDATA[gorm的几个默认规则如下： 默认的表名是定义的结构体名称小写复数形式 1234type Usr struct &#123; UsrId int Name string&#125; 该结构体对应的默认表名就是usrs 12345678// 全局禁用表名复数，如果设置为true,则`Usr`的默认表名为`user`,db.SingularTable(true)//但是如果使用TableName()显示设置了表名，则最终的表名以设置的为准//如下：设置User的表名为`profiles`func (User) TableName() string &#123; return "profiles"&#125; 列名是字段名的蛇形小写 大小写字母之间用_间隔 12345678910111213type User struct &#123; ID uint // 列名为 `id` Name string // 列名为 `name` Birthday time.Time // 列名为 `birthday` CreatedAt time.Time // 列名为 `created_at`&#125;//通过tag重设列名type Animal struct &#123; AnimalId int64 `gorm:"column:beast_id"` // 设置列名为`beast_id` Birthday time.Time `gorm:"column:day_of_the_beast"` // 设置列名为`day_of_the_beast` Age int64 `gorm:"column:age_of_the_beast"` // 设置列名为`age_of_the_beast`&#125; 字段ID为默认主键1234567891011type User struct &#123; ID uint // 字段`ID`为默认主键 Name string&#125;// 使用tag`primary_key`用来设置主键type Animal struct &#123; AnimalId int64 `gorm:"primary_key"` // 设置AnimalId为主键 Name string Age int64&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[GORM之Automigrate]]></title>
    <url>%2F2019%2F05%2F06%2Fgorm-automigrate%2F</url>
    <content type="text"><![CDATA[gorm中的Automigrate()操作，其作用主要是刷新数据库中的表格，使其保持最新，即让数据库之前存储的记录的表格字段和程序中最新使用的表格字段保持一致（只增不减）。 以sqlite数据库存储为例(数据库文件查看，可以使用sqlite browser)： 第一次写入数据库的字段内容为 12345type Product struct &#123; gorm.Model Code string Price string&#125; 其在数据库的存储格式如下： 新增字段如果Product新增一个Age字段如下： 123456type Product struct &#123; gorm.Model Code string Price string Age string&#125; 调用automigrate后， 1db.AutoMigrate(&amp;Product&#123;&#125;) 数据库会自动为之前存储的item新增age字段，内容为空（NULL） 删除字段1234type Product struct &#123; gorm.Model Code string&#125; 调用Automigrate后，数据库之前记录的item保持不变，新增item只有Code一个column，price和age保持为空（NULL）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Golang之GORM框架的基本使用]]></title>
    <url>%2F2019%2F05%2F05%2Fgo-gorm-base%2F</url>
    <content type="text"><![CDATA[ORM（对象关系映射): 把数据库映射成对象。ORM 使用对象，封装了数据库操作，因此可以不碰 SQL 语言。开发者只使用面向对象编程，与数据对象直接交互，不用关心底层数据库实现； gorm是使用go语言实现数据库访问的ORM库。使用这个库，我们可以利用面向对象的方法，更加方便的对数据库中的数据进行CRUD(数据库的基本操作有四种：create、read、update和delete，简称 CRUD)，而无需关心底层数据库的具体实现以及数据库的类型(支持多种类型的数据库，例如MySQL，SQLite，PostgreSQL，MSSQL)。 基本使用:官方教程 下载依赖12$go get github.com/jinzhu/gorm$go get github.com/jinzhu/gorm/dialects/mysql 第一个是核心库。第二个是mysql数据库的驱动包，如果使用的是其他数据库，则需下载相应数据库的驱动包。 gorm包装了一些常用数据库的驱动，直接下载即可： 1234//import _ "github.com/jinzhu/gorm/dialects/mysql"//import _ "github.com/jinzhu/gorm/dialects/postgres"//import _ "github.com/jinzhu/gorm/dialects/sqlite"//import _ "github.com/jinzhu/gorm/dialects/mssql" 连接数据库12345678910111213141516171819202122232425262728293031packae mainimport ( "github.com/jinzhu/gorm" _ "github.com/jinzhu/gorm/dialects/mysql" "fmt")func main() &#123; db, err := gorm.Open("mysql","root:12345@/demo?charset=utf8&amp;parseTime=True&amp;loc=Local") if err != nil &#123; fmt.Println(err) return &#125; defer db.Close() // Migrate the schema db.AutoMigrate(&amp;Product&#123;&#125;) // Create db.Create(&amp;Product&#123;Code: "L1212", Price: 1000&#125;) // Read var product Product db.First(&amp;product, 1) // find product with id 1 db.First(&amp;product, "code = ?", "L1212") // find product with code l1212 // Update - update product's price to 2000 db.Model(&amp;product).Update("Price", 2000) // Delete - delete product db.Delete(&amp;product)&#125; 上面代码中 mysql 是数据库驱动，root 是数据库用户名，12345 是密码，demo 则是数据库名称。 新增数据12345678910type User struct &#123; gorm.Model ID int `gorm:"primary_key"` Name string `gorm:"not_null"`&#125;func add() &#123; user := &amp;User&#123;Name:"David"&#125; db.Create(user)&#125; User类型中内嵌了gorm.Model字段，gorm.Model会自动为User｛｝添加如下4个字段： id：索引 create_at：数据条目生成时间 updated_at：数据条目更新时间 deleted_at：数据条目删除时间 删除数据12user := &amp;User&#123;ID:1&#125;db.Delete(user) 更新数据12user := &amp;User&#123;ID:1&#125;db.Model(user).Update("Name","lisi") 查询数据123456789//查询所有条目var users []Userdb.Find(&amp;users)fmt.Println(users)//查询ID为1的条目user := new (User)db.First(user,1)fmt.Println(user) 其它:判断数据库中是否有结构体对应的表：1db.HasTable(User&#123;&#125;) 创建表1db.CreateTable(User&#123;&#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Goroutine]]></title>
    <url>%2F2019%2F04%2F30%2Fgoroutine-introduce%2F</url>
    <content type="text"><![CDATA[goroutine是go语言中的一种并发机制，实现简单，在需要异步执行的函数前加上go关键字即可，该函数即会异步执行。事实上，⼊⼝函数 main 就以 goroutine 运⾏。 但是需要⚠️的是：调度器不能保证多个 goroutine 执⾏次序，且进程退出时不会等待它们结束。所以这两点都需要在程序设计时从整体逻辑来考虑 123go func() &#123; println("Hello, World!")&#125;()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go接口的实现技巧]]></title>
    <url>%2F2019%2F04%2F30%2Fgo-interface-func%2F</url>
    <content type="text"><![CDATA[本文讲述一种比较少见的接口实现用法：用函数实现接口。 直接上代码： 1234567891011121314//Tester接口，包含Do()方法type Tester interface &#123; Do()&#125;type FuncDo func()//实现Do方法func (self FuncDo) Do() &#123; self() &#125;func main() &#123; var t Tester = FuncDo(func() &#123; println("Hello, World!") &#125;) t.Do()&#125; 输出： Hello, World! FuncDo类型实现了Do方法，所以可以将其赋值给Tester接口(该接口仅包含Do方法)。然后通过调用Tester接口类型t的方法来间接实现FuncDo函数Do方法的调用]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go空接口之类型转换]]></title>
    <url>%2F2019%2F04%2F29%2Fgo-empty-interface%2F</url>
    <content type="text"><![CDATA[话不多说，直接看代码 1234567891011121314type User struct &#123; id int name string&#125;func main() &#123; u := User&#123;1, "Tom"&#125; var i interface&#123;&#125; = u u.id = 2 u.name = "Jack" fmt.Printf("%v\n", u) fmt.Printf("%v\n", i.(User))&#125; 输出： 12&#123;2 Jack&#125;&#123;1 Tom&#125; 在赋值给空接口时，使用指针，再运行看下效果 12345678910111213type User struct &#123; id int name string&#125;func main() &#123; u := User&#123;1, "Tom"&#125; var vi, pi interface&#123;&#125; = u, &amp;u //copy u and assign to vi // vi.(User).name = "Jack" // Error: cannot assign to vi.(User).name pi.(*User).name = "Jack" fmt.Printf("%v\n", vi.(User)) fmt.Printf("%v\n", pi.(*User))&#125; 输出： 12&#123;1 Tom&#125;&amp;&#123;1 Jack&#125; 空接⼝转型返回临时对象（该临时对象的内存只能读，不能写），只有使⽤指针才能修改其状态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go方法集和方法表达式]]></title>
    <url>%2F2019%2F04%2F29%2Fgo-methods-expression%2F</url>
    <content type="text"><![CDATA[直接看代码 方法集： 1234567891011121314151617type User struct &#123; id int name string&#125;func (self User) Test() &#123; fmt.Println(self)&#125;func main() &#123; u := User&#123;1,"test"&#125; mValue := u.Test //⽴即复制 receiver，因为不是指针类型，不受后续修改影响 u.id, u.name = 2, "modified" u.Test() mValue()&#125; 输出： 12&#123;2 modified&#125;&#123;1 test&#125; 修改上述代码，将Test()方法的receiver类型改为指针 123func (self *User) Test() &#123; fmt.Println(self)&#125; 重新运行上述代码，输出： 12&#123;2 modified&#125;&#123;2 modified&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go中的数组]]></title>
    <url>%2F2019%2F04%2F28%2Fgo-array%2F</url>
    <content type="text"><![CDATA[go中的数组不同于c/c++中的数组，是值类型，在函数参数传递的时候，会拷贝整个数组(不同于c/c++中数组名相当于指针)。 数组的长度为const，当不指定长度时，类型变为切片（slice） 数组的几种初始化方式： 12345678910a := [3]int&#123;1, 2&#125; // 未初始化元素值为 0。b := [...]int&#123;1, 2, 3, 4&#125; // 通过初始化值确定数组⻓度。c := [5]int&#123;2: 100, 4:200&#125; // 使⽤索引号初始化元素。d := [...]struct &#123; name string age uint8&#125;&#123; &#123;"user1", 10&#125;, // 可省略元素类型。 &#123;"user2", 20&#125;, // 别忘了最后⼀⾏的逗号。&#125; 内置函数 len 和 cap 都返回数组⻓度 (元素数量)。 12a := [2]int&#123;&#125;println(len(a), cap(a)) // 2,2]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go语言内置的所有数据类型]]></title>
    <url>%2F2019%2F04%2F28%2Fgo-all-data-type%2F</url>
    <content type="text"><![CDATA[列表为go内置的所有数据类型，包括基本数据类型，例如int，byte，rune，string；也有引用数据类型，例如slice，map，channel等；还有interface，函数等 如果想获取任何类型变量的存储地址，使用&amp;（取地址符） 12str := "you are my sunshine"fmt.Printf("addr:%p\n", &amp;str) 输出： 1addr:0xc0000621c0 字符串一旦创建不可修改，所以如果要修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。⽆论哪种转换，都会重新分配内存，并复制字节数组（本质上，修改后的字符串已不是原始的字符串，他们彼此占用了独立的内存空间）。 123456s := "abcd"b := []byte(s)b[0]='A'fmt.Printf("b:%s\n",b)fmt.Printf("s addr:%p\n",&amp;s)fmt.Printf("b addr:%p\n",&amp;b) 输出： 123b:Abcds addr:0xc000094010b addr:0xc000096000 Go 函数返回局部变量指针是安全的，不同于c/c++，编译器会根据需要，将该局部变量的内存分配在GC Heap上 123456789101112func main()&#123; p := test() fmt.Println("in main:",p) *p = 88 fmt.Printf("modified:%d\n",*p)&#125;func test() *int &#123; x := 100 fmt.Printf("local var addr:%p\n",&amp;x) return &amp;x&#125; 输出： 123local var addr:0xc000094000in main: 0xc000094000 //同一个空间modified:88 //可以访问返回的局部变量地址空间]]></content>
  </entry>
  <entry>
    <title><![CDATA[go语言中的interface类型]]></title>
    <url>%2F2019%2F04%2F25%2Fgo-interface%2F</url>
    <content type="text"><![CDATA[go语言中的interface类型，作用类似于c语言中的void指针。有着非常灵活的应用场景]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go可变参数函数]]></title>
    <url>%2F2019%2F04%2F23%2Fgo-variadic-param-func%2F</url>
    <content type="text"><![CDATA[可变参数函数即其参数数量是可变的 : 0 个或多个； 声明可变参数函数的方式是在其参数类型前面带上省略符（…）前缀。 一个简单的可变参数函数： 1234567func test(input …string) string &#123; return strings.Join(input,",")&#125;test("hello","world")test("single")test() 可变参数函数会在其内部创建一个”新的临时切片”。事实上，可变参数是一个简化了切片类型参数传入的语法糖。 当不传入参数的时候，可变参数会成为一个空值切片（ nil ) 当不太确定数据类型的时候我们通常采用空接口 interface{} 1234567tests1(789)fmt.Println("-------------")tests1("789")func tests1(arg interface&#123;&#125;) &#123; fmt.Println("value:", arg) fmt.Println("type:", reflect.TypeOf(arg).Name())&#125; 输出结果 12345value: 789type: int-------------value: 789type: string ⚠️在使用interface{}作为可变入参时，传入的参数要先做类型转换(先转换为[ ]interface{}) 1234567891011121314151617181920func testParams(args ...interface&#123;&#125;) &#123; for i, v := range args &#123; if s, ok := v.(string); ok &#123; fmt.Println("----", s) &#125; if s, ok := v.([]string); ok &#123; for i, v := range s &#123; fmt.Println(i, "[]----", v) &#125; &#125; fmt.Println(i, v) &#125;&#125;s := []string&#123;"4", "5", "6"&#125;var d []interface&#123;&#125;d = append(d, s)//或者//var d []interface&#123;&#125; = []interface&#123;&#125;&#123;s[0], s[1], s[2]&#125;testParams(d...) 结果: 12340 []---- 41 []---- 52 []---- 60 [4 5 6]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go中切片之间的浅拷贝和深拷贝]]></title>
    <url>%2F2019%2F04%2F22%2Fgo-slice-copy%2F</url>
    <content type="text"><![CDATA[我们知道，go语言中切片类型是从数组类型基础上发展出来的新类型，当声明一个数组时，不指定该数组长度，则该类型为切片(“动态数组”)，切片有自己独立的内部结构字段(len, cap, array pointer)，并共用底层数组空间。 例如： 12var s1 [10]int //数组var s2 []int //切片 切片属于引用类型，使用make分配内存空间和初始化成员结构。 12a := make([]int, 3) //长度为3b := make([]int, 3, 5) //长度为3，容量为5 切片字面量初始化： 数组到切片的拷贝(共享底层数组空间) 切片之间的拷贝分为2种：浅拷贝和深拷贝 浅拷贝：源切片和目的切片共享同一底层数组空间，源切片修改，目的切片同样被修改。 1234567891011package mainimport "fmt"func main()&#123; slice1 := make([]int, 5, 5) slice2 := slice1 slice1[1] = 1 fmt.Println(slice1) //[0 1 0 0 0] fmt.Println(slice2) //[0 1 0 0 0]&#125; 深拷贝：源切片和目的切片各自都有彼此独立的底层数组空间，各自的修改，彼此不受影响 12345678910111213141516171819package mainimport "fmt"func main()&#123; slice1 := make([]int, 5, 5) slice1[0]=9 slice2 := make([]int, 4, 4) slice3 := make([]int, 5, 5) //拷贝 fmt.Println(copy(slice2, slice1))//4 fmt.Println(copy(slice3, slice1))//5 //独立修改 slice2[1] = 2 slice3[1] = 3 fmt.Println(slice1)//[9 0 0 0 0 0] fmt.Println(slice2)//[9 2 0 0] fmt.Println(slice3)//[9 3 0 0 0]&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[升级做爸爸了，开心]]></title>
    <url>%2F2019%2F04%2F17%2Fnew-son-new-life%2F</url>
    <content type="text"><![CDATA[内心憧憬了很久，一直心情很平静；但是当第一眼真正看到他的时候，内心还是受到了很大的冲击，眼里泛着泪花，激动的心情良久难以平复。哈哈，我可爱的儿子，我们终于见面了。辛苦妈妈十月怀胎，爸爸特此为你开一贴，感谢妈妈，以示纪念！ 我帅气的胖儿子]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建go程序源码编译环境]]></title>
    <url>%2F2019%2F04%2F11%2Fuse-softlink-for-go-build-env%2F</url>
    <content type="text"><![CDATA[编译go语言程序，需要将源码放在特定结构和目录名称的的工程环境中，并设置GOPATH环境变量. GOPATH最后一层目录名为src，同级的目录有bin，pkg目录，程序源码需要放在src下面。如下图所示： 但是通常我们在git代码库上提交的源码，并不一定是按照上述目录结构组织的。所以为了方便编译，而又不挪动源码，我们使用软链接的方法为需要编译的go源码搭建一个编译环境。 base_service工程中的Zeus是需要编译的go源码，在该目录中是无法直接使用go build命令进行编译的。 建立go编译工程目录：在外面任意位置新建编译目录build_go，里面分别建立src，bin，pkg等3个字目录 建立软连接:1$ln -sf /Users/bitmain/work/master/bitmain_gerrit/base_service/Zeus /Users/bitmain/work/master/bitmain_gerrit/go_build/src/Zeus 设置GOPATH环境变量:env.sh如下: 1$export GOPATH=$GOPATH:/Users/bitmain/work/master/bitmain_gerrit/go_build 编译：然后在go_build目录下执行编译脚本build.sh即可完成编译： 1234#!/bin/bashpushd /Users/bitmain/work/master/bitmain_gerrit/go_build/srcgo build -o zeus entry.gopopd]]></content>
  </entry>
  <entry>
    <title><![CDATA[python opencv图像金字塔]]></title>
    <url>%2F2019%2F04%2F10%2Fopencv-pyramid-sample%2F</url>
    <content type="text"><![CDATA[通俗点讲， 对一个图片进行金字塔操作，涉及如下两个函数； pyrDown( )函数的作用是向下采样并模糊一张图片，说白了就是缩小一张图片。 pyrUp( )函数的作用是向上采样并模糊一张图像，说白了就是放大一张图片； python示例代码： 1234567891011121314151617import cv2def pyramid(): img = cv2.imread('.\obma.jpg', cv2.IMREAD_COLOR) lower_reso1 = cv2.pyrDown(img) lower_reso2 = cv2.pyrDown(lower_reso1) lower_reso3 = cv2.pyrDown(lower_reso2) cv2.imshow('original', img) cv2.imshow('pyrdown1', lower_reso1) cv2.imshow('pyrdown2', lower_reso2) cv2.imshow('pyrdown3', lower_reso3) cv2.waitKey(0) cv2.destroyAllWindows()if __name__=='__main__': pyramid() 每调用一次pyrDown()操作，图片的H,W就减小至原来的一半。故面积缩小至原来的四分之一; 预览： pyrUp()相反，每调用一次，图片的H,W就增大至原来的2倍。故面积增大至原来的4倍; 需要注意的是，PryUp和PryDown不是互逆的，即PryUp不是降采样的逆操作。如果一张图片先调用pyrdown()一次，然后再调用pyrUp()，图片大小会恢复至原始大小，但是图像清晰度会下降。]]></content>
  </entry>
  <entry>
    <title><![CDATA[opencv python生成BGR三原色]]></title>
    <url>%2F2019%2F04%2F09%2Fcv2-bgr-sample%2F</url>
    <content type="text"><![CDATA[OpenCV能够处理图片的颜色通道顺序为为BGR（blue，green，red），即每个像素点由3个值组成，这3个值分别代表blue, green, red的值。 介绍一种简单的生成BGR三原色图片的方法。 原理：将另外两个通道的值置为0，本通道值置为255即可。 python示例如下： 123456789101112131415161718192021import cv2import numpy as npdef color(): blue = np.zeros([300,300,3],dtype='uint8') blue[:,:,0] = 255 green = np.zeros([300,300,3],dtype='uint8') green[:,:,1] = 255 red = np.zeros([300,300,3],dtype='uint8') red[:,:,2] = 255 cv2.imshow('blue',blue) cv2.imshow('green', green) cv2.imshow('red', red) cv2.waitKey(0) cv2.destroyAllWindows()if __name__=='__main__': color() 运行，预览：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python函数参数传递中的*号使用]]></title>
    <url>%2F2019%2F04%2F08%2Fpython-func-decompress-arglist%2F</url>
    <content type="text"><![CDATA[主要包含单引号和双引号的用法 单星号(*) 将所有参数以元组(tuple)的形式导入： 1234567&gt;&gt;&gt; def foo(param1, *param2): print param1 print param2&gt;&gt;&gt; foo('a',2,3,4,5)'a'(2, 3, 4, 5) 解压参数列表 123456&gt;&gt;&gt; def foo(param1, param2): print param1,param2&gt;&gt;&gt; input = [1,2]&gt;&gt;&gt; foo(*input)1,2 双引号(**) 将参数以字典(dict)的形式导入 1234567891011&gt;&gt;&gt; def foo(a, b=2, *args, **kwargs) print a print b print args print kwargs&gt;&gt;&gt; foo(1,23,3,4,e=5,f=6,g=7)123(3,4)&#123;'e':5,'f':6,'g':7&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go类型转换]]></title>
    <url>%2F2019%2F04%2F08%2Fgo-type-cast%2F</url>
    <content type="text"><![CDATA[Go语言不支持隐式类型转换，即使如下几种情况也不允许 同类型别名之间的转换123type INT intvar a INT = 10var b int = a // Error: ... 窄类型向宽类型转换12var b byte = 100var n int = b //Error: ... Go只支持显示类型转换 12var b byte = 10var n int = int(b)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac终端配色]]></title>
    <url>%2F2019%2F04%2F06%2Fmac-terminal-color%2F</url>
    <content type="text"><![CDATA[mac的terminal默认显示是灰白的，无法方便的区分普通文件，目录，可执行程序或者链接文件。本文介绍，借助于Coreutils工具模仿ubuntu的terminal默认配色，在mac terminal上还原ubuntu经典配色。 安装工具1$brew install coreutils 如果是因为无法翻墙的原因，可参考我上一篇文章中的方法-如何使terminal通过vpn联网 生成颜色定义文件1$gdircolors --print-database &gt; ~/.dir_colors 我们可以修改~/.dir_colors，添加自定义文件的颜色，此文件中的注释已经包含各种颜色取值的说明。 自定义文件颜色在~/.dir_colors尾部添加对各种源码文件及配置文件格式的支持 12345678910# code format.c 01;33.cpp 01;33.h 01;33.go 01;33.py 01;33.s 01;31.md 4;37.json 01;35.yml 01;35 添加启动配置在~/.bash_profile或者~/.bashrc配置文件中加入以下代码 12345if brew list | grep coreutils &gt; /dev/null ; then PATH="$(brew --prefix coreutils)/libexec/gnubin:$PATH" alias ls='ls -F --show-control-chars --color=auto' eval `gdircolors -b $HOME/.dir_colors`fi gdircolor的作用就是设置ls命令使用的环境变量LS_COLORS（BSD是LSCOLORS） 修改PS1，模拟ubuntu terminal prompt在~/.bash_profile或者~/.bashrc配置文件中加入以下代码，可以模拟Ubuntu terminal中prompt的配色 1export PS1='$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ ' 预览：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac终端通过VPN联网]]></title>
    <url>%2F2019%2F04%2F06%2Fmac-terminal-proxy%2F</url>
    <content type="text"><![CDATA[通常情况，mac链接vpn后，浏览器可以直接通过vpn联网；然而终端默认是不通过vpn的，所以对于程序员来说，这却是一个极大的不便利: 无法通过各种命令行工具下载文件，例如wget，curl，git get，apt-get等。 下面介绍一种简单的方法，使得terminal通过vpn联网 1$export http_proxy=http://proxyAddress:port vpn工具联网成功后，在terminal上执行上述命令，则可使的terminal通过vpn联网 该方法临时有效，退出终端后失效。如果希望保持一直有效，可将上述命令添加到~/.bashrc等启动配置文件中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go环境变量]]></title>
    <url>%2F2019%2F04%2F06%2Fgo-env%2F</url>
    <content type="text"><![CDATA[介绍几个go语言编程中常用的环境变量，都可以通过export指令修改 $GOROOT go编译器程序的安装目录 $GOPATH go项目工程的根目录 该目录下必须包含src，pkg，bin3个子目录 $GOBIN go程序编译完成后生成的可执行binary，使用go install命令时，自动安装到$GOPATH/bin下 $GOOS $GOARCH 目标平台的操作系统类型和芯片架构类型，这两个参数主要用于交叉编译中 go支持多种操作系统和芯片体系结构，故go对交叉编译也有很好的支持 使用如下命令可以查看当前环境中go相关的环境变量 1$go env Linux1234567891011121314151617181920212223242526GOARCH="amd64"GOBIN=""GOCACHE="/home/lwang/.cache/go-build"GOEXE=""GOFLAGS=""GOHOSTARCH="amd64"GOHOSTOS="linux"GOOS="linux"GOPATH="/home/lwang/go"GOPROXY=""GORACE=""GOROOT="/usr/local/go"GOTMPDIR=""GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64"GCCGO="gccgo"CC="gcc"CXX="g++"CGO_ENABLED="1"GOMOD=""CGO_CFLAGS="-g -O2"CGO_CPPFLAGS=""CGO_CXXFLAGS="-g -O2"CGO_FFLAGS="-g -O2"CGO_LDFLAGS="-g -O2"PKG_CONFIG="pkg-config"GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build193074853=/tmp/go-build -gno-record-gcc-switches" Mac1234567891011121314151617181920212223242526GOARCH="amd64"GOBIN=""GOCACHE="/Users/bitmain/Library/Caches/go-build"GOEXE=""GOFLAGS=""GOHOSTARCH="amd64"GOHOSTOS="darwin"GOOS="darwin"GOPATH="/Users/bitmain/go"GOPROXY=""GORACE=""GOROOT="/usr/local/go"GOTMPDIR=""GOTOOLDIR="/usr/local/go/pkg/tool/darwin_amd64"GCCGO="gccgo"CC="clang"CXX="clang++"CGO_ENABLED="1"GOMOD=""CGO_CFLAGS="-g -O2"CGO_CPPFLAGS=""CGO_CXXFLAGS="-g -O2"CGO_FFLAGS="-g -O2"CGO_LDFLAGS="-g -O2"PKG_CONFIG="pkg-config"GOGCCFLAGS="-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/5x/6gkjj0_1581fwz9lvylk14mr0000gn/T/go-build089246083=/tmp/go-build -gno-record-gcc-switches -fno-common"]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go build模式之c-archive，c-shared，linkshared]]></title>
    <url>%2F2019%2F04%2F05%2Fgo-buildmode-c%2F</url>
    <content type="text"><![CDATA[本文用实例介绍这3种模式的构建方法； go程序中需要被导出的方法Hello()： 1234567891011121314//hello.gopackage mainimport "C"import "fmt"func main() &#123; Hello("hello")&#125;//export Hellofunc Hello(name string) &#123; fmt.Println("output:",name)&#125; 注意事项： 1.//export Hello，这是约定，所有需要导出给 C 调用的函数，必须通过注释添加这个构建信息，否则不会构建生成 C 所需的头文件; 2.导出函数的命名的首字母是否大写，不受go规则的影响，大小写均可; 3.头部必须添加import “C”; c-archive模式：1$go build --buildmode=c-archive hello.go 编译生成hello.a和C头文件hello.h 在所生成的 hello.h 的头文件中，我们可以看到 Go 的 Hello() 函数的定义： 123456789#ifdef __cplusplusextern "C" &#123;#endif...extern void Hello(GoString p0);...#ifdef __cplusplus&#125;#endif 在头文件中GoString的定义如下： 123456typedef struct &#123; const char *p; ptrdiff_t n; &#125; _GoString_;typedef _GoString_ GoString; 然后我们可以在 hello.c 中引用该头文件，并链接Go编译的静态库： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include "hello.h"int main(int argc, char *argv[])&#123; char *type = argv[1]; char buf[] = "test for "; char input[16]=&#123;0&#125;; sprintf(input, "%s %s", buf, type); GoString str; str.p = input; str.n = strlen(input); Hello(str); return 0;&#125; 然后，构建 C 程序： 1$gcc -o hello_static hello.c hello.a -lpthread c-shared模式：1$go build --buildmode=c-shared -o libhello.so hello.go 编译生成libhello.so 构建c程序，并链接动态库 1$gcc -o hello_dynamic hello.c -L./ -lhello -lpthread -L 指定链接库为当前目录 -l 指定所需要连接的动态库名称，去掉lib前缀和.so后缀 linkshared模式： 该模式主要用于为go程序编译动态链接库 12$sudo /usr/local/go/bin/go install -buildmode=shared std$sudo /usr/local/go/bin/go build -linkshared -o hello_linkshared hello.go 编译生成hello_linkshared可执行程序 附上实例程序编译脚本 12345678910111213141516171819202122232425# !/bin/bash# staticgo build --buildmode=c-archive hello.gogcc -o hello_static hello.c hello.a -lpthreadecho "=== run static binary ==="./hello_static static# dynamicgo build --buildmode=c-shared -o libhello.so hello.gogcc -o hello_dynamic hello.c -L./ -lhello -lpthreadecho "=== run dynamic binary ==="./hello_dynamic dynamic# linkshared for gosudo /usr/local/go/bin/go install -buildmode=shared stdsudo /usr/local/go/bin/go build -linkshared -o hello_linkshared hello.goecho "=== run linkshared binary ==="ls -lh ./hello_linkshared./hello_linkshared# default , static for gogo build -o hello_static_go hello.gols -lh ./hello_static_go./hello_static_go 输出：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go简短模式声明变量之部分退化赋值]]></title>
    <url>%2F2019%2F04%2F04%2Fgo-short-assignment%2F</url>
    <content type="text"><![CDATA[golang 函数内定义变量，推荐使用简短模式，例如： 12x := 1y := "hello" 由于作用域的关系，该模式容易定义跟全局变量同名的函数局部新变量，使用的时候要特别小心。 12345678//全局变量xvar x = 100func main() &#123; //重新定义和初始化同名的局部变量x x := "abc" fmt.Println(x)&#125; 输出： 1abc 但是简短模式并不总是定义新变量，在重复使用的时候可能执行的是部分退化赋值操作 部分退化赋值的前提条件：最少有一个新变量被定义，且必须是在同一作用域 123456789101112package mainimport "fmt"func main() &#123; x := 100 fmt.Println("x:",x, " &amp;x:",&amp;x) fmt.Println("========== seperate ========") x , y := 200 , "abc" fmt.Println("x:",x, " &amp;x:",&amp;x) fmt.Println("y:",y, " &amp;y:",&amp;y)&#125; 输出： 1234x: 100 &amp;x: 0xc00006c080========== seperate ========x: 200 &amp;x: 0xc00006c080y: abc &amp;y: 0xc0000581c0 从输出结果可以看出，前后两次打印的x地址都是同一个，故可以说明前后两次x是同一个变量，仅仅是值发生了变化。 部分退化赋值这一特性可以用在处理函数错误返回值，允许重复使用err变量，非常方便 123456789101112131415161718package mainimport ( "gocv.io/x/gocv" "log")func main() &#123; val1, err := func1() if err != nil &#123; log.Fatal(err) &#125; ... val2, err := func2() if err != nil &#123; log.Fatal(err) &#125;&#125;]]></content>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go build模式]]></title>
    <url>%2F2019%2F04%2F04%2Fgo-build-mode%2F</url>
    <content type="text"><![CDATA[build mode: 用于指导编辑器如何创建可执行的二进制文件。越多的执行方式，就意味着可以让 Go 运行在更多的地方。 1$go build -buildmode=default goroutine_select.go 在编译go程序时，go编译器支持如下几种模式： 1234567891011121314151617181920212223242526272829303132333435363738-buildmode=archive Build the listed non-main packages into .a files. Packages named main are ignored.-buildmode=c-archive Build the listed main package, plus all packages it imports, into a C archive file. The only callable(可调用的) symbols will be those functions exported using a cgo //export comment. Requires exactly one main package to be listed.-buildmode=c-shared Build the listed main package, plus all packages it imports, into a C shared library. The only callable symbols will be those functions exported using a cgo //export comment. Requires exactly one main package to be listed.-buildmode=default Listed main packages are built into executables and listed non-main packages are built into .a files (the default behavior).-buildmode=shared Combine all the listed non-main packages into a single shared library that will be used when building with the -linkshared option. Packages named main are ignored.-buildmode=exe Build the listed main packages and everything they import into executables. Packages not named main are ignored.-buildmode=pie Build the listed main packages and everything they import into position independent executables (PIE). Packages not named main are ignored.-buildmode=plugin Build the listed main packages, plus all packages that they import, into a Go plugin. Packages not named main are ignored. 解释： 12345678exe: 静态编译exe: 动态链接 libcexe: 动态链接 libc 和非 Go 代码pie: 地址无关的可执行文件(安全特性)c-archive: C 的静态链接库c-shared: C 的动态链接库shared: Go 的动态链接库plugin: Go 的插件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go多变量赋值]]></title>
    <url>%2F2019%2F04%2F03%2Fgo-multi-assign%2F</url>
    <content type="text"><![CDATA[Go语言支持一次定义多个变量，同时也支持多个变量赋值。 例如： 1var x , y = "abc", 100 多变量赋值 原则1：要优先计算所有相关值，然后再从左到右依次赋值 123data , i := []int&#123;1,2,3&#125;, 1i , data[i] = 2, 100fmt.Println(i, data) 输出结果： 12 [1,100,3] i本身的值为1，在被赋值为2之前，data[i] -&gt; data[1] 优先，所以i=2， data[1] = 100 原则2：要优先计算出所有右值，然后再从左到右依次赋值 123x, y := 1, 2x, y = y+3, x+2println(x,y) 输出： 15,3]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用GoCV进行人脸检测]]></title>
    <url>%2F2019%2F04%2F03%2Fgocv-face-detection%2F</url>
    <content type="text"><![CDATA[示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( "fmt" "gocv.io/x/gocv" "image" "image/color" "log")func main() &#123; webCam , err := gocv.VideoCaptureDevice(0) if err != nil &#123; log.Fatal(err) &#125; defer webCam.Close() window := gocv.NewWindow("face") defer window.Close() img := gocv.NewMat() defer img.Close() classifier := gocv.NewCascadeClassifier() defer classifier.Close() if !classifier.Load("/data/haarcascade_frontalface_default.xml") &#123; log.Fatal("load model failed\n") &#125; for &#123; if ok := webCam.Read(&amp;img); !ok &#123; log.Fatalln("read img from webcam failed") &#125; if img.Empty() &#123; continue &#125; rects := classifier.DetectMultiScale(img) fmt.Printf("found %d face\n",len(rects)) for _ , ret := range rects &#123; color := color.RGBA&#123;0,0,225,0&#125; gocv.Rectangle(&amp;img, ret, color,3) size := gocv.GetTextSize("human",gocv.FontHersheyPlain, 1.2, 2) pt := image.Pt(ret.Min.X+(ret.Min.X/2)-(size.X/2), ret.Min.Y-2) gocv.PutText(&amp;img, "Human", pt, gocv.FontHersheyPlain, 1.2, color, 2) &#125; window.IMShow(img) if window.WaitKey(1) &amp; 0xff == int('q') &#123; break &#125; &#125;&#125; 编译 1$go build test_face_detection.go 执行结果： 按q键，退出]]></content>
  </entry>
  <entry>
    <title><![CDATA[GoCV：使用Go和OpenCV4.0.1进行计算机视觉编程]]></title>
    <url>%2F2019%2F04%2F03%2Fgocv-introduction%2F</url>
    <content type="text"><![CDATA[To use GoCV, you must install OpenCV 4.0.1 on your system. Linux环境安装 Mac 环境安装 示例代码： This example opens a video capture device using device “0”, reads frames, and shows the video in a GUI window: 12345678910111213141516package mainimport ( "gocv.io/x/gocv")func main() &#123; webcam, _ := gocv.VideoCaptureDevice(0) window := gocv.NewWindow("Hello") img := gocv.NewMat() for &#123; webcam.Read(&amp;img) window.IMShow(img) if (window.WaitKey(1) &amp; 0xff == int('q') &#123; break &#125; &#125;&#125; 编译程序，并执行 12$go build -o test_cv gocv_example.go$./test_cv 如果执行过程出现如下错误： 1./test_cv: error while loading shared libraries: libopencv_calib3d.so.4.0: cannot open shared object file: No such file or directory 解决办法： 1$export LD_LIBRARY_PATH=/home/chengwei/work/github/opencv-4.0.1/release/lib:$LD_LIBRARY_PATH 执行效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用clion编译c++程序报错]]></title>
    <url>%2F2019%2F04%2F02%2Fclion-compile-err%2F</url>
    <content type="text"><![CDATA[问题描述：Clion编译c++程序，报错 “wchar.h not found” 12345678/Library/Developer/CommandLineTools/usr/include/c++/v1/wchar.h:119:15:** **fatal error:** 'wchar.h' file not found**\#include_next &lt;wchar.h&gt;^~~~~~~~~1 error generated.make[2]: *** [CMakeFiles/test_virtual.bin.dir/test_virtual.cpp.o] Error 1make[1]: *** [CMakeFiles/test_virtual.bin.dir/all] Error 2make: *** [all] Error 2 解决办法：click “Tools -&gt; CMake -&gt; ResetCache and Reload Project” 重新编译即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[在Dockerfile中使用COPY指令]]></title>
    <url>%2F2019%2F04%2F02%2Fdockerfile-copy%2F</url>
    <content type="text"><![CDATA[COPY指令:1COPY &lt;src&gt; &lt;dest&gt; 我们在使用dockerfile构建docker镜像时，通常会用到COPY指令。COPY指令用于将系统本地的文件拷贝至docker镜像中。但是其中有一个地方需要特别注意：即build上下文. 在使用 docker build 命令通过 Dockerfile 创建镜像时，会产生一个 build 上下文(context)。所谓的 build 上下文就是 docker build 命令的 PATH 或 URL 指定的路径中的文件的集合。在镜像 build 过程中可以引用上下文中的任何文件，比如我们要介绍的 COPY 命令，就可以引用上下文中的文件。 默认情况下 docker build -t custom . 命令中的 . 表示build上下文为当前目录。 当然我们可以指定一个目录作为上下文，比如： 1$docker build -t custom /home/linaro 注意事项：在使用COPY指令时，本地的源文件要位于build上下文中。 如果build上下文是当前目录，则源文件要位于dockerfile所在的当前目录。 例如： 12WORKDIR /workCOPY snmp . snmp目录要位于dockerfile所在的目录中 否则build过程中会报错：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git for Gerrit 客户端配置指导]]></title>
    <url>%2F2019%2F04%2F02%2Fgit-and-gerrit-guide%2F</url>
    <content type="text"><![CDATA[Install and config Gitinstall git1$sudo apt-get install git config git1$git config --global user.name "Your Name" 1$git config --global user.email "your.email@gmail.com" Note：”Your Name” must be same with your domain name, for example wei.cheng Check config information1$git config --list Generate and upload ssh keyOn Linux 1$ssh-keygen -t rsa -C "your.email@gmail.com" Don’t use any passphrase 1$vim ~/.ssh/config 123456----------------------------------------------------------------Host * KexAlgorithms +diffie-hellman-group1-sha1---------------------------------------------------------------- 1$cat ~/.ssh/id_rsa.pub Copy the whole file into clipboardOpen gerrit website , On website, goto “Settings -&gt; SSH Public Keys”, paste the key, press “Add” Clone projects12345678910111213141516$git clone &lt;ssh://your.name@gerrit.ai.bmfusion.net:29418/xxx.git&gt;$git submodule init$git submodule update --rebase --remote$git fetch origin$git rebase origin/master#Do merge if needed, after solving conflict, run$git rebase --continue#Amend the previous change if needed$git commit --amend#Push$git push origin HEAD:refs/for/master]]></content>
  </entry>
  <entry>
    <title><![CDATA[OpenCV源码编译安装]]></title>
    <url>%2F2019%2F04%2F02%2Fopencv-src-compile%2F</url>
    <content type="text"><![CDATA[从官网下载最新版4.0.1源码，解压缩，并按以下步骤执行： 进入源码目录1$cd opencv-4.0.1 创建编译目录build，使用cmake进行源码外编译 如果系统没有安装cmake工具，请先安装cmake 1$mkdir build 进入编译目录1$cd build 配置 指定编译后lib文件和头文件的安装路径为/usr/local，默认生成pkgconfig文件，编译python2&amp;3接口 1$cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_GENERATE_PKGCONFIG=ON -D BUILD_opencv_python2=ON -D BUILD_opencv_python3=ON ../ 编译 j值为CPU核数 1$make -j4 安装1$sudo make install 注：如果cmake配置增加 -D BUILD_opencv_world=ON 选项编译，会将所有动态库融合为一个动态库opencv_world.so 结果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go编程语法注意事项]]></title>
    <url>%2F2019%2F04%2F01%2Fgo-syntax%2F</url>
    <content type="text"><![CDATA[看完《Go语言实战》和《Go核心编程》这两本教程，自己总结了一些使用Go编程的要领和注意事项 使用 := 赋值操作符，这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明； 全局变量允许声明但不使用，但是局部变量声明后不使用，则编译会报错； 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，但是两个变量的类型必须相同； Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑； 字符串是一种值类型，且值不可变，即创建某个文本后你无法再次修改这个文本的内容；更深入地讲，字符串是字节的定长数组； 获取字符串中某个字节的地址的行为是非法的，例如： 12str := "hello world"&amp;str[i] switch语句case中不需要break来结束; 未初始化的map的值是nil。map默认是无序的,既不是按照key的顺序排列，也不是按照value排序的; 无论是结构体还是结构体指针类型，都使用点号来获取结构体字段（不同于C/C++，指针使用-&gt;来获取成员变量）; 如果File是一个结构体类型，那么表达式 12new(File)&amp;File&#123; &#125; 是等价的 在一个结构体中,对于每一种数据类型只能有一个匿名字段; 内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法，比较类似于面向对象里面的继承; 空接口： type Any interface{ }，不实现任何方法，所以任何类型都实现了空接口. 可以给一个空接口类型的变量赋任何类型的值， 每个空接口类型变量占用2个字节：一个用来存储它包含的类型，另一个用来存储它包含的数据或者指向数据的指针,空接口类似于C语言的*void指针； 复制数据切片至空接口切片必须逐一赋值，因为内存布局不一样； 结构struct中只有被导出字段（首字母大写）才是可设置的； 实际上，反射是通过检查一个接口的值，变量首先被转换成空接口； 类型可以通过内嵌多个接口来提供像多重继承一样的特性； 函数重载通过空接口实现； 封装：1）包范围内的：通过标识符首字母小写，对象只在它所在的包内可见；2）可导出的：通过标识符首字母大写，对象对所在包以外也可见； 继承： 用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现； 多态： 用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现； 字节切片初始化方式： 1）圆括号会进行类型转换；2）花括号则直接赋值； 当调用panic时，所有的defer语句都会保证执行，并把控制权交还给panic的函数调用者； panic会导致栈被展开直到defer修饰的recover()被调用或者程序中止，recover只能在defer修饰的函数； 执行go test用于测试单个文件时，一定要后跟被测试的源代码文件，如果原文件有其他的引用，有需要一并跟上，否则会提示引用找不到的错误； 协程工作在相同的地址空间，所以共享内存的方式一定是同步的；协程是轻量的，比线程更轻; 经验法则，对于n个核心的情况设置GOMAXPROCS 为n-1以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1+GOMAXPROCS &gt; 1； 如果在某一时间只有一个协程在执行，不要设置GOMAXPROCS！ GOMAXPROCS等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行； 协程会随着程序的结束而自动消亡； 协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序； 通道只能传输一种类型的数据, 所有的类型都可以用于通道，空接口interface{}也可以。甚至可以（有时非常有用）创建通道的通道； 一个无缓冲通道只能包含1个元素, 带缓冲的通道包含多个元素； 关闭通道： 只有发送者才需要关闭通道，接收者不需要关闭通道； 所有处于同一个文件夹里的代码文件，必须使用同一个包名。按照惯例，包和文件夹同名； import导入包时，如果包名前有下划线_，表示初始化该包，但是不是用包里的变量； 程序中每个代码文件里的 init 函数都会在 main 函数执行前调用； 包中任意一个公开的标识符。这些标识符以大写字母开头。以小写字母开头的标识符是不公开的，不能被其其包中的代码直接访问； 包名应该使用全小写命名 如果使用 … 替代数组的长度，Go 语言会根据初始化时数组元素的数量来确定该数组的长度； 如果在[ ]运算符里指定了一个值，那么创建的就是数组而不是切片。只有为空的时候，才会创建切片； nil切片不同于空切片, 成员指针变量的值不一样，前者值为nil，后者值为0； 切片赋值，共享底层数组； 如果在创建切片时设置切片的容量和长度一样，就可以强制让新切片的第一个 append 操作创建新的底层数组，与原有的底层数组分离。新切片与原有的底层数组分离后，可以安全地进行后续修改； 在函数间传递切片，就是要在函数间以值的方式传递切片，这里值传递是指的拷贝地址，实际的切片元素值是不用拷贝的； 在64位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节； 由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。复制时只会复制切片本身，不会涉及底层数组，值传递； 用type声明的新类型与原类型是两个完全不同的类型，不能互相赋值； go语言里面有两种类型的接受者（1-值接收者；2-指针接收者） 两种类型的方法，可以彼此互相调用; 值接收者使用值的副本来调用方法，而指针接受者使用实际值来调用方法(方法对值的修改会影响实际值)。 在实际编写代码时，还要看值类型，是否方便复制（如果值中包含未公开类型，则不能复制） 接口： 用来定义行为的类型。这些被定义的行为不由接口直接实现，而是通过方法由用户定义的类型实现； 123type Maker interface &#123; Make()&#125; 当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见 带缓冲的通道，当主动close通道后，goroutine依然可以从通道接收数据，但是不能再往通道发送数据了 iota的使用，默认为0，逐步递增； 字符串类型在 go里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节 在定义常量组时，如果不提供初始值，则表示将使用上一行的表达式； 123456789const ( Sunday = 0 Monday Tuesday Wednesday Thursday Friday Saturday) Sunday为0，其他常量均为0 可以通过将非可变参数置于可变参数前面的方式来混合使用它们，注意：非可变参数只能放在可变参数前面； 使用os.Exit(0)函数退出程序，之前声明的defer函数不会执行； go语言有指针，但是没有指针运算，不能对指针进行偏移； 初始化顺序： 全局变量 -&gt; init() -&gt; main()； package 基本的管理单元：同一个package下面，可以有非常多的不同文件，只要每个文件的头部 都有 如 “package xxx” 的相同name, 表示这些文件属于同一个包； import导入包滥用时，可能会存在循环依赖的问题，需要主动避免； 空切片和nil切片是两个完全不同的概念；nil切片：只声明，不做初始化空切片：声明后初始化为空]]></content>
  </entry>
  <entry>
    <title><![CDATA[上传Docker镜像到私有镜像仓储]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-priv-repo-setup%2F</url>
    <content type="text"><![CDATA[出于信息安全，版本控制等因素考虑，自己搭建docker镜像仓储（搭建教程本文不介绍），可以方便有效的管理大量本地的docker镜像。本文主要介绍如何上传本地的docker镜像到自己搭建的私有镜像仓储 配置本地docker在 /etc/docker/daemon.json（如果没有该文件，则可创建一个） 填入如下字段: 12345&#123; "insecure-registries":[ "10.30.37.149:6000" ]&#125; 10.30.37.149为自己搭建的docker镜像仓储服务器IP，6000为服务器开放的端口 然后执行以下命令重新启动docker 1$sudo systemctl reload docker 如果不做以上配置，push镜像的时候会报以下错误：http: server gave HTTP response to HTTPS client 给需要上传的镜像打tag1$sudo docker tag 3dbe0975429e 10.30.37.149:6000 /bm1682_debian:1.1.1 3dbe0975429e 为本地需要上传的镜像的IMAGE ID， tag格式：私有镜像仓储服务器IP:端口/镜像名称:版本号 上传镜像到私有仓储1$sudo docker push 10.30.37.149:6000/bm1682_debian:1.1.1 下载私有仓储的镜像到本地1sudo docker pull 10.30.37.149:6000/bm1682_debian:1.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 容器端口映射方法]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-port-expose%2F</url>
    <content type="text"><![CDATA[docker容器在启动的时候，如果不指定端口映射参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 现在有如下两种方式导出端口： 启动容器的时候通过-P，-p或者–expose参数动态指定： 端口映射支持的格式 ip : host port : container port #指定宿主机ip、指定宿主机port、指定容器 ip :: container port #指定ip、指定容器port host port : container port #指定宿主机port、指定容器port 1$docker run -P -it ubuntu /bin/bash 以上指令会将容器暴露的所有端口，都随机映射到宿主机上(不推荐) 1$docker run -P 80 -it ubuntu /bin/bash 以上指令会将容器的80端口随机映射到宿主机的一个端口上 1$docker run -p 8000:80 -it ubuntu /bin/bash 以上指令会将容器的80端口映射到宿主机的8000端口上 1$docker run -P 192.168.0.100::80 -it ubuntu /bin/bash 以上指令会将容器的IP 192.168.0.100和80端口，映射到宿主机的8000端口 1docker run -p 1000-2000:1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，映射到宿主机端口1000-2000 1$docker run --expose=1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，随机映射到宿主机端口上 在Dockerfile里面通过EXPOSE指令静态配置：EXPOSE指令只是指定暴露容器内部端口，映射规则还需要在运行容器时通过-P参数指定 1234567891011# GET_IMAGEFROM centos# MAINTAINER_INFOMAINTAINER hongxue hongxue@showjoy.comRUN yum -y install vim# PORTEXPOSE 8080EXPOSE 22 上述Dockerfile暴露了容器内的8080和22两个端口给宿主机。 运行容器时，通过增加-P参数，Docker会自动为用户创建端口映射规则，并且帮助避免端口映射的冲突，这两个端口会被随机映射到宿主机上的两个端口上， 1$docker run -d -it -P --name container_name image_name EXPOSE指令也支持指定端口范围 1EXPOSE 7000-8000 查看指定容器端口映射配置:示例： 12$docker port container_ID ``#容器ID80/tcp -&gt; 0.0.0.0:800]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP ARM部署]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp-deployment%2F</url>
    <content type="text"><![CDATA[交叉编译 net-snmp交叉编译，生成snmpd 交叉编译企业私有节点动态库 libbmserv.so 简单版配置文件snmpd.conf1234567891011121314151617181920212223242526272829############################################################################ snmpd.conf###########################################################################dlmod bmserv /usr/lib/libbmserv.so#v1/v2crocommunity rrrrrrwcommunity wwww#v1 traptrapsink 10.30.33.2 rrrrr#v2c traptrap2sink 10.30.33.2 rrrrr#v2c informinformsink 10.30.33.2 rrrrr#v3engineIDType 3rouser rouser privcreateUser rouser MD5 11111111 DES 22222222rwuser rwuser privcreateUser rwuser MD5 33333333 DES 44444444# v3 traptrapsess -v 3 -u rouser -a MD5 -A 11111111 -x DES -X 22222222 -l priv 192.168.1.111 engineType. 1|2|3 : SNMP v3的安全配置，engine id的产生依赖于此选项自动生成； 配置了该选项，就不需要在trapsess选项中通过-e参数来手动指定engine id，否则就需要. specifies that the engineID should be built from the IPv4 address (1), IPv6 address (2) or MAC address (3). Note that changing the IP address (or switching the network interface card) may cause problems. ARM部署将snmpd，libbmserv.so，snmpd.conf及相关的net-snmp库文件打包，然后放到arm开发环境。 snmpd一般放在/bin目录下，snmpd.conf一般放在/etc/snmp/config目录下(没有的话，可自己建立相应的目录) libbmserv.so及net-snmp的动态库文件都可以放在/usr/local/lib下，私有mib文件及公共mib文件都放在/usr/share/mibs下，通过MIBS环境变量指定路径 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/Bitmain.mib 手动启动1$snmpd -f -c /etc/snmp/config/snmpd.conf 全部可选参数如下： OPTIONS -a Log the source addresses of incoming requests. -A Append to the log file rather than truncating it. 默认每次重新启动snmpd，snmpd.log会被清理掉以便重新记录日志，之前旧的日志会被丢弃; 添加-A选项后，旧日志被保留，新的日志追加在旧的日志尾部 -c FILE Read FILE as a configuration file (or a comma-separated list of configuration files). Note that the loaded file will only understand snmpd.conf tokens, unless the configuration type is specified in the file as described in the snmp_config man page under SWITCHING CONFIGURATION TYPES IN MID-FILE. -C Do not read any configuration files except the ones optionally specified by the -c option. Note that this behaviour also covers the persistent configuration files. This may result in dynamically-assigned values being reset following an agent restart, unless the relevant persistent config files are explicitly loaded using the -c option. -d Dump (in hexadecimal) the sent and received SNMP packets. -D[TOKEN[,…]] Turn on debugging output for the given TOKEN(s). Without any tokens specified, it defaults to printing all the tokens (which is equivalent to the keyword “ALL”). You might want to tryALL for extremely verbose output. Note: You can not put a space between the -D flag and the listed TOKENs. -f Do not fork() from the calling shell. -g GID Change to the numerical group ID GID after opening listening sockets. -h, –help Display a brief usage message and then exit. -H Display a list of configuration file directives understood by the agent and then exit. -I [-]INITLIST Specifies which modules should (or should not) be initialized when the agent starts up. If the comma-separated INITLIST is preceded with a ‘-‘, it is the list of modules that should notbe started. Otherwise this is the list of the only modules that should be started.To get a list of compiled modules, run the agent with the arguments -Dmib_init -H (assuming debugging support has been compiled in). -L[efos] Specify where logging output should be directed (standard error or output, to a file or via syslog). See LOGGING OPTIONS in snmpcmd(5) for details. -m MIBLIST Specifies a colon separated list of MIB modules to load for this application. This overrides the environment variable MIBS. See snmpcmd(1) for details. -M DIRLIST Specifies a colon separated list of directories to search for MIBs. This overrides the environment variable MIBDIRS. See snmpcmd(1) for details. -n NAME Set an alternative application name (which will affect the configuration files loaded). By default this will be snmpd, regardless of the name of the actual binary. -p FILE Save the process ID of the daemon in FILE. -q Print simpler output for easier automated parsing. -r Do not require root access to run the daemon. Specifically, do not exit if files only accessible to root (such as /dev/kmem etc.) cannot be opened. -u UID Change to the user ID UID (which can be given in numerical or textual form) after opening listening sockets. -U Instructs the agent to not remove its pid file (see the -p option) on shutdown. Overrides the leave_pidfile token in the snmpd.conf file, see snmpd.conf(5). -v, –version Print version information for the agent and then exit. -V Symbolically dump SNMP transactions. -x ADDRESS Listens for AgentX connections on the specified address rather than the default “/var/agentx/master”. The address can either be a Unix domain socket path, or the address of a network interface. The format is the same as the format of listening addresses described below. -X Run as an AgentX subagent rather than as an SNMP master agent. –name=value Allows to specify any token (“name”) supported in the snmpd.conf file and sets its value to “value”. Overrides the corresponding token in the snmpd.conf file. See snmpd.conf(5) for the full list of tokens. SNMP服务自启动利用debian的systemd机制，编写snmpd.service文件(xxx.service是snmp依赖的服务,根据实际情况修改) 12345678910111213141516[Unit]Description=Simple Network Management Protocol (SNMP) DaemonAfter=syslog.target network.target xxx.serviceRequires=xxx.service[Service]Environment=LD_LIBRARY_PATH=/usr/libEnvironment=MIBDIRS=/usr/share/snmp/mibsType=simplePIDFile=/var/run/snmpd.pidExecStart=/bin/snmpd -f -c /etc/snmp/config/snmpd.conf -p /var/run/snmpd.pidRestart=on-failureRestartSec=3[Install]WantedBy=multi-user.target 执行enable命令 1$systemctl enable snmpd 系统下电重启，则SNMP服务会自动重新启动 其他控制操作1.启动 1$systemctl start snmpd 2.停止 1$systemctl stop snmpd 3.重启 1$systemctl restart snmpd 4.查询 1$systemctl status snmpd]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP企业节点动态库编辑]]></title>
    <url>%2F2019%2F03%2F29%2Fenterprise-priv%2F</url>
    <content type="text"><![CDATA[查阅net-snmp的相关资料，目前Net-SNMP有多种使用方式。本文只介绍snmpd + 企业私有节点动态库的方式。目前这种方式也在多数企业中得到广泛使用。使用这种方式的优点：不用修改net-snmp源码；第一次交叉编译net-snmp生成snmpd后，后面新增feature，修复bug等不需要重新编译net-snmp源码，仅仅维护企业节点动态库就可以了。 企业节点动态库初始化函数在使用mib2c工具自动生成相应代码后，还需要在代码中添加一个启动函数，该启动函数是snmpd守护进程调用企业节点动态库的入口： 123void init_bmserv(void)｛ ...｝ 该函数bmserv的命名应同生成的动态库名称libbmserv.so要保持一致 Makefile交叉编译动态库，模版makefile如下(根据实际环境进行修改适配)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#************************************************************# 通用Makefile#************************************************************CC = aarch64-linux-gnu-gcc#************************************************************# 编译选项#************************************************************# 宏定义选项MACRO_FLAGS := # 使用到的库，只要写lib后的名称，不用加.so或.aLIB_FLAGS := curl crypto cjson# 编译.c到.o文件的选项CC_FLAGS := -Wall -fPIC# 连接.o文件用到的选项LINK_FLAGS := -Wall -fPIC -lpthread -shared#************************************************************# 源代码目录#************************************************************ROOT := $(shell pwd)SRCDIRS := $(ROOT)# ************************************************************# 头文件目录# ************************************************************INCLUDE_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/include/#************************************************************# 动态库、静态库目录#************************************************************LIB_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/openssl/lib/arm64/#************************************************************# 最终生成的程序名称#************************************************************TARGET := libbmserv.so#************************************************************# 被编译的.c文件#************************************************************SRC_C := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))#************************************************************# 所有的.o文件#************************************************************OBJ_C := $(notdir $(patsubst %.c, %.o, $(SRC_C)))#************************************************************# 编译规则#************************************************************.PHONY: all cmd_init cmd_last cleanall:cmd_init $(TARGET) cmd_last# 编译前命令cmd_init: @echo "SRC DIR:" $(SRCDIRS) @echo cmd_init# 编译后命令cmd_last: @echo cmd_lastVPATH = $(SRCDIRS)$(TARGET):$(OBJ_C) $(CC) $(LINK_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) $(LIB_DIRS:%=-L%) -o $@ $^ $(LIB_FLAGS:%=-l%) $(OBJ_C):%.o:%.c $(CC) $(CC_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) -c -o $@ $&lt;clean: rm -f *.o rm -f $(TARGET) 编译 1$make 即可在当前目录下生成企业私有节点动态库libbmserv.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[mib2c代码自动生成]]></title>
    <url>%2F2019%2F03%2F29%2Fmib2c%2F</url>
    <content type="text"><![CDATA[要使用mib2c工具自动生成Net-SNMP企业私有库代码，首先必须在开发环境中部署mib2c工具。该工具是net-snmp源码自带的，直接编译net-snmp源码后就可以使用了。 mib2c环境部署1.配置 1$./configure 2.编译 1$make 3.安装（如果没有在configure指定安装目录，则会安装到系统默认目录/usr/local/net-snmp） 1$make install mib2c生成代码1.设置环境变量，将需要生成代码的企业私有mib(xxx.mib)路径导出到环境变量 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/demo.mib 2.为leaf节点生成代码(xxx为demo.mib文件中modIdent节点名称) 1$/usr/local/net-snmp/bin/mib2c -c mib2c.scalar.conf xxx 3.为table节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.iterate.conf xxx 4.为notification节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.notify.conf xxx 在生成的代码中，添加自己的实现即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP的交叉编译 for ARM64]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp%2F</url>
    <content type="text"><![CDATA[1.交叉编译openssl去官网下载openssl-1.0.2q.tar.gz，解压缩到目录/home/lwang/work/chengw/github/下，然后进入openssl目录按照如下步骤操作 1) 配置编译选项 1$./config no-asm shared --cross-compile-prefix=aarch64-linux-gnu- --prefix=/home/lwang/work/chengw/github/openssl-1.1.1a/release 其中参数的含义为：no-asm：在交叉编译过程中不使用汇编代码代码加速编译过程；shared：生成动态链接库；–prefix：指定生成lib、include、bin三个核心目录的路径，不修改此项则默认为OPENSSLDIR目录。 2) 修改生成的Makefile，去掉-m64选项，否则会编译报错3) 编译 1$make -j4 4) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 2.交叉编译net-snmp在官网下载net-snmp-5.7.3.tar.gz，解压缩到/home/lwang/work/chengw/github/目录，然后进入net-snmp目录,并按照如下步骤操作 1) 配置编译选项 1$./configure --host=arm-linux --target=arm-linux --build=i686-linux --with-cc=aarch64-linux-gnu-gcc --with-ar=aarch64-linux-gnu-ar --prefix=/home/lwang/work/chengw/github/net-snmp-5.7.3/release --with-endianness=little --disable-manuals --disable-embedded-perl --disable-perl-cc-checks --without-perl-modules --disable-scripts --disable-applications --with-openssl=/home/lwang/work/chengw/github/openssl-1.0.2q/release 2) 编译 1$make -j4 3) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 注意：实际测试发现，net-snmp 5.7.3只能搭配openssl-1.0.2q版本使用，更新的版本会编译报错.]]></content>
  </entry>
</search>
