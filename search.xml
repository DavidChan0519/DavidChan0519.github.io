<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[go_syntax]]></title>
    <url>%2F2019%2F04%2F01%2Fgo-syntax%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[上传Docker镜像到私有镜像仓储]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-priv-repo-setup%2F</url>
    <content type="text"><![CDATA[出于信息安全，版本控制等因素考虑，自己搭建docker镜像仓储（搭建教程本文不介绍），可以方便有效的管理大量本地的docker镜像。本文主要介绍如何上传本地的docker镜像到自己搭建的私有镜像仓储 1.配置本地docker在 /etc/docker/daemon.json（如果没有该文件，则可创建一个） 填入如下字段: 12345&#123; "insecure-registries":[ "10.30.37.149:6000" ]&#125; 10.30.37.149为自己搭建的docker镜像仓储服务器IP，6000为服务器开放的端口 然后执行以下命令重新启动docker 1$sudo systemctl reload docker 如果不做以上配置，push镜像的时候会报以下错误：http: server gave HTTP response to HTTPS client 2.给需要上传的镜像打tag1$sudo docker tag 3dbe0975429e 10.30.37.149:6000 /bm1682_debian:1.1.1 3dbe0975429e 为本地需要上传的镜像的IMAGE ID， tag格式：私有镜像仓储服务器IP:端口/镜像名称:版本号 ![/images/docker_tag.png] 3.上传镜像到私有仓储1$sudo docker push 10.30.37.149:6000/bm1682_debian:1.1.1 4.下载私有仓储的镜像到本地1sudo docker pull 10.30.37.149:6000/bm1682_debian:1.1.1]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 容器端口映射方法]]></title>
    <url>%2F2019%2F04%2F01%2Fdocker-port-expose%2F</url>
    <content type="text"><![CDATA[docker容器在启动的时候，如果不指定端口映射参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。 现在有如下两种方式导出端口： 1.启动容器的时候通过-P ，-p 或者–expose参数动态指定： 端口映射支持的格式 ip : host port : container port #指定宿主机ip、指定宿主机port、指定容器 ip :: container port #指定ip、指定容器port host port : container port #指定宿主机port、指定容器port 1$docker run -P -it ubuntu /bin/bash 以上指令会将容器暴露的所有端口，都随机映射到宿主机上(不推荐) 1$docker run -P 80 -it ubuntu /bin/bash 以上指令会将容器的80端口随机映射到宿主机的一个端口上 1$docker run -p 8000:80 -it ubuntu /bin/bash 以上指令会将容器的80端口映射到宿主机的8000端口上 1$docker run -P 192.168.0.100::80 -it ubuntu /bin/bash 以上指令会将容器的IP 192.168.0.100和80端口，映射到宿主机的8000端口 1docker run -p 1000-2000:1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，映射到宿主机端口1000-2000 1$docker run --expose=1000-2000 -it ubuntu /bin/bash 以上指令会将容器的1000-2000的所有端口，随机映射到宿主机端口上 2.在Dockerfile里面通过EXPOSE指令静态配置：EXPOSE指令只是指定暴露容器内部端口，映射规则还需要在运行容器时通过-P参数指定 1234567891011# GET_IMAGEFROM centos# MAINTAINER_INFOMAINTAINER hongxue hongxue@showjoy.comRUN yum -y install vim# PORTEXPOSE 8080EXPOSE 22 上述Dockerfile暴露了容器内的8080和22两个端口给宿主机。 运行容器时，通过增加-P参数，Docker会自动为用户创建端口映射规则，并且帮助避免端口映射的冲突，这两个端口会被随机映射到宿主机上的两个端口上， 1$docker run -d -it -P --name container_name image_name EXPOSE指令也支持指定端口范围 1EXPOSE 7000-8000 3.查看指定容器端口映射配置:示例： 12$docker port container_ID ``#容器ID80/tcp -&gt; 0.0.0.0:800]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP企业节点动态库编辑]]></title>
    <url>%2F2019%2F03%2F29%2Fenterprise-priv%2F</url>
    <content type="text"><![CDATA[查阅net-snmp的相关资料，目前Net-SNMP有多种使用方式。本文只介绍snmpd + 企业私有节点动态库的方式。目前这种方式也在多数企业中得到广泛使用。使用这种方式的优点：不用修改net-snmp源码；第一次交叉编译net-snmp生成snmpd后，后面新增feature，修复bug等不需要重新编译net-snmp源码，仅仅维护企业节点动态库就可以了。 企业节点动态库初始化函数在使用mib2c工具自动生成相应代码后，还需要在代码中添加一个启动函数，该启动函数是snmpd守护进程调用企业节点动态库的入口： 123void init_bmserv(void)｛ ...｝ 该函数bmserv的命名应同生成的动态库名称libbmserv.so要保持一致 Makefile交叉编译动态库，模版makefile如下(根据实际环境进行修改适配)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#************************************************************# 通用Makefile#************************************************************CC = aarch64-linux-gnu-gcc#************************************************************# 编译选项#************************************************************# 宏定义选项MACRO_FLAGS := # 使用到的库，只要写lib后的名称，不用加.so或.aLIB_FLAGS := curl crypto cjson# 编译.c到.o文件的选项CC_FLAGS := -Wall -fPIC# 连接.o文件用到的选项LINK_FLAGS := -Wall -fPIC -lpthread -shared#************************************************************# 源代码目录#************************************************************ROOT := $(shell pwd)SRCDIRS := $(ROOT)# ************************************************************# 头文件目录# ************************************************************INCLUDE_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/include/INCLUDE_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/include/#************************************************************# 动态库、静态库目录#************************************************************LIB_DIRS := $(ROOT)/../../../../prebuilt/3rdparty/curl-7.60.0/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/net-snmp/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/cJSON/lib/arm64/LIB_DIRS += $(ROOT)/../../../../prebuilt/3rdparty/openssl/lib/arm64/#************************************************************# 最终生成的程序名称#************************************************************TARGET := libbmserv.so#************************************************************# 被编译的.c文件#************************************************************SRC_C := $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))#************************************************************# 所有的.o文件#************************************************************OBJ_C := $(notdir $(patsubst %.c, %.o, $(SRC_C)))#************************************************************# 编译规则#************************************************************.PHONY: all cmd_init cmd_last cleanall:cmd_init $(TARGET) cmd_last# 编译前命令cmd_init: @echo "SRC DIR:" $(SRCDIRS) @echo cmd_init# 编译后命令cmd_last: @echo cmd_lastVPATH = $(SRCDIRS)$(TARGET):$(OBJ_C) $(CC) $(LINK_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) $(LIB_DIRS:%=-L%) -o $@ $^ $(LIB_FLAGS:%=-l%) $(OBJ_C):%.o:%.c $(CC) $(CC_FLAGS) $(MACRO_FLAGS:%=-D%) $(INCLUDE_DIRS:%=-I%) -c -o $@ $&lt;clean: rm -f *.o rm -f $(TARGET) 编译 1$make 即可在当前目录下生成企业私有节点动态库libbmserv.so]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP ARM部署]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp-deployment%2F</url>
    <content type="text"><![CDATA[交叉编译 net-snmp交叉编译，生成snmpd 交叉编译企业私有节点动态库 libbmserv.so 简单版配置文件snmpd.conf1234567891011121314151617181920212223242526272829############################################################################ snmpd.conf###########################################################################dlmod bmserv /usr/lib/libbmserv.so#v1/v2crocommunity rrrrrrwcommunity wwww#v1 traptrapsink 10.30.33.2 rrrrr#v2c traptrap2sink 10.30.33.2 rrrrr#v2c informinformsink 10.30.33.2 rrrrr#v3engineIDType 3rouser rouser privcreateUser rouser MD5 11111111 DES 22222222rwuser rwuser privcreateUser rwuser MD5 33333333 DES 44444444# v3 traptrapsess -v 3 -u rouser -a MD5 -A 11111111 -x DES -X 22222222 -l priv 192.168.1.111 engineType. 1|2|3 : SNMP v3的安全配置，engine id的产生依赖于此选项自动生成； 配置了该选项，就不需要在trapsess选项中通过-e参数来手动指定engine id，否则就需要. specifies that the engineID should be built from the IPv4 address (1), IPv6 address (2) or MAC address (3). Note that changing the IP address (or switching the network interface card) may cause problems. ARM部署将snmpd，libbmserv.so，snmpd.conf及相关的net-snmp库文件打包，然后放到arm开发环境。 snmpd一般放在/bin目录下，snmpd.conf一般放在/etc/snmp/config目录下(没有的话，可自己建立相应的目录) libbmserv.so及net-snmp的动态库文件都可以放在/usr/local/lib下，私有mib文件及公共mib文件都放在/usr/share/mibs下，通过MIBS环境变量指定路径 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/Bitmain.mib 手动启动1$snmpd -f -c /etc/snmp/config/snmpd.conf 全部可选参数如下： OPTIONS -a Log the source addresses of incoming requests. -A Append to the log file rather than truncating it. 默认每次重新启动snmpd，snmpd.log会被清理掉以便重新记录日志，之前旧的日志会被丢弃; 添加-A选项后，旧日志被保留，新的日志追加在旧的日志尾部 -c FILE Read FILE as a configuration file (or a comma-separated list of configuration files). Note that the loaded file will only understand snmpd.conf tokens, unless the configuration type is specified in the file as described in the snmp_config man page under SWITCHING CONFIGURATION TYPES IN MID-FILE. -C Do not read any configuration files except the ones optionally specified by the -c option. Note that this behaviour also covers the persistent configuration files. This may result in dynamically-assigned values being reset following an agent restart, unless the relevant persistent config files are explicitly loaded using the -c option. -d Dump (in hexadecimal) the sent and received SNMP packets. -D[TOKEN[,…]] Turn on debugging output for the given TOKEN(s). Without any tokens specified, it defaults to printing all the tokens (which is equivalent to the keyword “ALL”). You might want to tryALL for extremely verbose output. Note: You can not put a space between the -D flag and the listed TOKENs. -f Do not fork() from the calling shell. -g GID Change to the numerical group ID GID after opening listening sockets. -h, –help Display a brief usage message and then exit. -H Display a list of configuration file directives understood by the agent and then exit. -I [-]INITLIST Specifies which modules should (or should not) be initialized when the agent starts up. If the comma-separated INITLIST is preceded with a ‘-‘, it is the list of modules that should notbe started. Otherwise this is the list of the only modules that should be started.To get a list of compiled modules, run the agent with the arguments -Dmib_init -H (assuming debugging support has been compiled in). -L[efos] Specify where logging output should be directed (standard error or output, to a file or via syslog). See LOGGING OPTIONS in snmpcmd(5) for details. -m MIBLIST Specifies a colon separated list of MIB modules to load for this application. This overrides the environment variable MIBS. See snmpcmd(1) for details. -M DIRLIST Specifies a colon separated list of directories to search for MIBs. This overrides the environment variable MIBDIRS. See snmpcmd(1) for details. -n NAME Set an alternative application name (which will affect the configuration files loaded). By default this will be snmpd, regardless of the name of the actual binary. -p FILE Save the process ID of the daemon in FILE. -q Print simpler output for easier automated parsing. -r Do not require root access to run the daemon. Specifically, do not exit if files only accessible to root (such as /dev/kmem etc.) cannot be opened. -u UID Change to the user ID UID (which can be given in numerical or textual form) after opening listening sockets. -U Instructs the agent to not remove its pid file (see the -p option) on shutdown. Overrides the leave_pidfile token in the snmpd.conf file, see snmpd.conf(5). -v, –version Print version information for the agent and then exit. -V Symbolically dump SNMP transactions. -x ADDRESS Listens for AgentX connections on the specified address rather than the default “/var/agentx/master”. The address can either be a Unix domain socket path, or the address of a network interface. The format is the same as the format of listening addresses described below. -X Run as an AgentX subagent rather than as an SNMP master agent. –name=value Allows to specify any token (“name”) supported in the snmpd.conf file and sets its value to “value”. Overrides the corresponding token in the snmpd.conf file. See snmpd.conf(5) for the full list of tokens. SNMP服务自启动利用debian的systemd机制，编写snmpd.service文件(xxx.service是snmp依赖的服务,根据实际情况修改) 12345678910111213141516[Unit]Description=Simple Network Management Protocol (SNMP) DaemonAfter=syslog.target network.target xxx.serviceRequires=xxx.service[Service]Environment=LD_LIBRARY_PATH=/usr/libEnvironment=MIBDIRS=/usr/share/snmp/mibsType=simplePIDFile=/var/run/snmpd.pidExecStart=/bin/snmpd -f -c /etc/snmp/config/snmpd.conf -p /var/run/snmpd.pidRestart=on-failureRestartSec=3[Install]WantedBy=multi-user.target 执行enable命令 1$systemctl enable snmpd 系统下电重启，则SNMP服务会自动重新启动 其他控制操作1.启动 1$systemctl start snmpd 2.停止 1$systemctl stop snmpd 3.重启 1$systemctl restart snmpd 4.查询 1$systemctl status snmpd]]></content>
  </entry>
  <entry>
    <title><![CDATA[mib2c代码自动生成]]></title>
    <url>%2F2019%2F03%2F29%2Fmib2c%2F</url>
    <content type="text"><![CDATA[要使用mib2c工具自动生成Net-SNMP企业私有库代码，首先必须在开发环境中部署mib2c工具。该工具是net-snmp源码自带的，直接编译net-snmp源码后就可以使用了。 mib2c环境部署1.配置 1$./configure 2.编译 1$make 3.安装（如果没有在configure指定安装目录，则会安装到系统默认目录/usr/local/net-snmp） 1$make install mib2c生成代码1.设置环境变量，将需要生成代码的企业私有mib(xxx.mib)路径导出到环境变量 1$export MIBS=/home/lwang/work/chengw/github/net-snmp-x86/MIB/demo.mib 2.为leaf节点生成代码(xxx为demo.mib文件中modIdent节点名称) 1$/usr/local/net-snmp/bin/mib2c -c mib2c.scalar.conf xxx 3.为table节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.iterate.conf xxx 4.为notification节点生成代码 1$/usr/local/net-snmp/bin/mib2c -c mib2c.notify.conf xxx 在生成的代码中，添加自己的实现即可]]></content>
  </entry>
  <entry>
    <title><![CDATA[Net-SNMP的交叉编译 for ARM64]]></title>
    <url>%2F2019%2F03%2F29%2Fnet-snmp%2F</url>
    <content type="text"><![CDATA[1.交叉编译openssl去官网（https://www.openssl.org/source/）下载openssl-1.0.2q.tar.gz，解压缩到目录/home/lwang/work/chengw/github/下，然后进入openssl目录按照如下步骤操作 1) 配置编译选项 1$./config no-asm shared --cross-compile-prefix=aarch64-linux-gnu- --prefix=/home/lwang/work/chengw/github/openssl-1.1.1a/release 其中参数的含义为：no-asm：在交叉编译过程中不使用汇编代码代码加速编译过程；shared：生成动态链接库；–prefix：指定生成lib、include、bin三个核心目录的路径，不修改此项则默认为OPENSSLDIR目录。 2) 修改生成的Makefile，去掉-m64选项，否则会编译报错3) 编译 1$make -j4 4) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 2.交叉编译net-snmp在官网(http://www.net-snmp.org/download.html)下载net-snmp-5.7.3.tar.gz，解压缩到/home/lwang/work/chengw/github/目录，然后进入net-snmp目录,并按照如下步骤操作 1) 配置编译选项 1$./configure --host=arm-linux --target=arm-linux --build=i686-linux --with-cc=aarch64-linux-gnu-gcc --with-ar=aarch64-linux-gnu-ar --prefix=/home/lwang/work/chengw/github/net-snmp-5.7.3/release --with-endianness=little --disable-manuals --disable-embedded-perl --disable-perl-cc-checks --without-perl-modules --disable-scripts --disable-applications --with-openssl=/home/lwang/work/chengw/github/openssl-1.0.2q/release 2) 编译 1$make -j4 3) 安装 1$make install 最终编译生成的头文件和lib文件都位于当前release目录下 注意：实际测试发现，net-snmp 5.7.3只能搭配openssl-1.0.2q版本使用，更新的版本会编译报错.]]></content>
  </entry>
</search>
